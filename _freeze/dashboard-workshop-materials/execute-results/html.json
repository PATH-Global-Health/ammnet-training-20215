{
  "hash": "427bc971583b17a7aab32db5a5b1174c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-On Shiny: Routine Malaria Data Dashboard Workshop\"\nauthor: \"AMMnet Senegal Workshop\"\ndate: \"June 25–27, 2025\"\nformat:\n  html:\n    theme: minty\n    toc: true\n    toc-depth: 6\n    toc-location: left\n    number-sections: false\n---\n\n\n\n\n# Setup\n\nWelcome to the “*Developing Data Visualisation Dashboards in R*” workshop! In this session, we’ll build a Shiny app step by step, exploring what Shiny can do - from basic reactive plots to interactive tables, maps, and advanced UI elements. Each section includes explanatory text, demo code, and exercises for you to try.\n\n> **Why RShiny?**\n>\n> -   Shiny lets you turn R code into interactive web applications without needing to learn HTML/CSS/JS.\n>\n> -   In malaria programs, routine data (e.g., DHIS2 exports) are key to monitoring. A Shiny dashboard can help stakeholders explore data visually, spot trends, and inform decisions and perform routine analysis.\n>\n> -   We'll continue using our DHIS2 dataset that we just downloaded and cleaned.\n\n::: callout-important\n**Before you begin:**\n\n-   Ensure you have your **R Studio Project** open.\n\n-   Ensure you have your DHIS2 cleaned data saved into the correct folder: `data-outputs/data_dhis2_laos_ammnet_cleaned.csv`\n\n-   If you didn't finish the steps in the earlier session - we have the dataset avaliable for download on the home page.\n:::\n\n## Install Packages\n\nWe need some addiditional packages for this session - install these packages if you don't have them already using the code below in the console:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"shiny\")\ninstall.packages(\"bslib\")\ninstall.packages(\"tidyverse\")\ninstall.packages(\"DT\")\ninstall.packages(\"plotly\")\ninstall.packages(\"leaflet\")\ninstall.packages(\"sf\")\ninstall.packages(\"lubridate\")\ninstall.packages(\"bsicons\")\n```\n:::\n\n\n\n\nThese packages will allow us to do the following:\n\n-   **`shiny`**: core package to build apps.\n\n-   **`bslib`**: theming (Bootstrap customization) and modern dashboard design elements.\n\n-   **`tidyverse`**: data wrangling (dplyr, ggplot2, readr…).\n\n-   **`DT`**: interactive tables.\n\n-   **`plotly`**: interactive plots.\n\n-   **`leaflet`** & **`sf`**: mapping spatial data.\n\n-   **`lubridate`**: for dealting with date-time.\n\n-   **`bsicons`**: for using Bootstrap icons in Shiny.\n\n## Objectives\n\nImagine you are a data analyst for the Minstry of Health and you've been tasked with creating a way for Provinces in the country to quickly and easily visualise and compare their malaria trends without the need for individual excel files or analyses. That's the kind of problem we're framing our dashboard around today. During this session you will:\n\n-   Understand key elements of Shiny Dashbaords\n\n-   Gain hands on experience customising Shiny dashbaords\n\nWe can't cover all aspects of creating Shiny Dashboards but there are a tonne of great resources online we will share during the course of today!\n\nWe'll start by highlighting some key building blocks of dashbboards before moving into customisations and visualisation rendering.\n\nIn the end we hope you will have created something like the dashboard as shown below:\n\n![](images/final-final.PNG)\n\n::: callout-tip\nTips for this tutorial\n\n-   After each step of the tutorial ensure you press **Run App or Refresh App** to visualise your changes\n\n-   Sometimes cleaning the environment or restartng R can be helpful when if your app isn't updating with changes.\n\n-   To check the definition, usage and arguements of functions type ? followed by the funcition name in the Console e.g. `?value_box`.\n\n-   When designing a Shiny App - always think about the end user and their journey through the application.\n:::\n\n## Set up App Skeleton\n\nNow we have Shiny installed we can create our first App. Open up a new R script and save it as `app.R` in your main project folder.\n\nCopy the code below which is a demo app the is built into the `Shiny` package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    https://shiny.posit.co/\n#\n\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui <- fluidPage(\n\n    # Application title\n    titlePanel(\"Old Faithful Geyser Data\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"bins\",\n                        \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput(\"distPlot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver <- function(input, output) {\n\n    output$distPlot <- renderPlot({\n        # generate bins based on input$bins from ui.R\n        x    <- faithful[, 2]\n        bins <- seq(min(x), max(x), length.out = input$bins + 1)\n\n        # draw the histogram with the specified number of bins\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n```\n:::\n\n\n\n\nThis is a simple pre-built demo that generates an app with a slider `sliderInput` to determine the number of bins on the corresponding histogram plot. You can see with just a few lines of code how easy it is to generate an interactive application!\n\n-   When you run this with **Run App** in RStudio, Shiny launches a local web app .\n\n-   **Reactivity**: When an input changes, reactive code re-executes and updates outputs automatically.\n\nLets close this app and go ahead and build own now!\n\n## Anatomy of a Shiny App\n\nBefore jumping into code, a quick reminder of the basic app structure.\n\nA **Shiny app** has two key components:\n\n1.  **`UI`** (User Interface): defines what users see and interact with: inputs (dropdowns, sliders) and outputs (plots, tables, text). It controls the layout and appearance of your app.\n\n2.  **`Server`**: R code that reacts to user inputs, does computations, and sends rendered outputs to the UI. It contains the instructions that your computer needs to build your app\n\n3.  Finally the `shinyApp` function creates Shiny app objects from an explicit UI/server pair.\n\nLets remove the contents of the **UI** and **Server** code from the default application to give something like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    https://shiny.posit.co/\n#\n\nlibrary(shiny)\n\n#-Define UI for application - User Interface------------------------------------\nui <- fluidPage(\n  \n)\n\n#-Define server logic - Computations-------------------------------------------- \nserver <- function(input, output) {\n  \n  # reactive expressions, computations and render functions\n}\n\n#-Run the application-----------------------------------------------------------\nshinyApp(ui = ui, server = server)\n```\n:::\n\n\n\n\nNow add in our addiditional library calls that we had installed and will need for this application at the top of the script - **Ensure this is written outside of the `ui` and `server` functions**. This will ensure that these packages are loaded when the app starts up.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#-packages needed---------------------------------------------------------------\nlibrary(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(DT)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(lubridate)\nlibrary(bsicons)\n```\n:::\n\n\n\n\n## Read In Our Data\n\nNext we need to ensure we read in the correct data to be able to start creating and generating outputs.\n\nAdd the following code after the `library` calls and before the `UI` code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#-read in app data once on app start up-----------------------------------------\napp_data <- \n  read.csv(\"./data-outputs/data_dhis2_laos_ammnet_cleaned.csv\") \n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n     organisation_unit     period               var_name  value\n1 01 Vientiane Capital 2024-01-01          malaria_tests 102.00\n2 01 Vientiane Capital 2024-01-01 malaria_cases_per_1000   1.26\n3 01 Vientiane Capital 2024-01-01          malaria_cases  11.00\n4 01 Vientiane Capital 2024-02-01          malaria_tests 109.00\n5 01 Vientiane Capital 2024-02-01 malaria_cases_per_1000   1.58\n6 01 Vientiane Capital 2024-02-01          malaria_cases  12.00\n```\n\n\n:::\n:::\n\n\n\n\nYou might notice that the `period` colum has been read in as a `character` variable so we need to ensure that this is in `date` format.\n\nAdd the following line of code after you read in the dataset.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# re-classify period as a date \napp_data$period <- lubridate::as_date(app_data$period)\n```\n:::\n\n\n\n\nNow we have our data ready to use in the app, we can start building out the UI and Server components.\n\n# Part 1: Shiny Building Blocks\n\n## Setting up an Empty Layout\n\nFor this tutorial we will focus on building our Shiny app using [`bslib`](https://rstudio.github.io/bslib/index.html), a modern UI toolkit that gives your app a clean and responsive layout with minimal effort.\n\nWe'll begin by setting up a basic dashboard skeleton - no data or inputs yet - just the layout structure using `bslib::page_sidebar()`.\n\nThis gives us a two-pane layout:\n\n-   A sidebar (on the left) for inputs or filters\n\n-   A main content area (on the right) for plots, tables, or summaries\n\nPaste the following code into your `app.R` file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#-Load libraries----------------------------------------------------------------\nlibrary(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(DT)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(lubridate)\n\n#-read in app data once on app start up-----------------------------------------\napp_data <- \n  read.csv(\"./data-outputs/data_dhis2_laos_ammnet_cleaned.csv\") \n\n# re-classify period as a date \napp_data$period <- lubridate::as_date(app_data$period)\n\n#-Define UI for application - User Interface------------------------------------\nui <- page_sidebar(\n  title = \"My Dashboard\",  # Title shown in the top bar\n  \n  sidebar = \"Sidebar\",     # Placeholder sidebar content\n  \n  \"Main content area\"     # Placeholder for main content (e.g., plots or tables)\n  \n)\n\n#-Define server logic - Computations-------------------------------------------- \nserver <- function(input, output) {\n  # Placeholder for reactive expressions and outputs\n}\n\n#-Run the application-----------------------------------------------------------\nshinyApp(ui = ui, server = server)\n```\n:::\n\n\n\n\n**What This Does**\n\n| Component | Description |\n|------------------------------------|------------------------------------|\n| `page_sidebar()` | Creates a full-page layout with a sidebar + main area |\n| `title = \"...\"` | Sets the page title shown in the app’s header bar |\n| `sidebar = \"...\"` | Placeholder content for the sidebar (we’ll replace this with inputs soon) |\n| `\"Main content area\"` | Text shown in the main panel (this will later become plots and tables) |\n\nClick **Run App** in RStudio. You’ll see:\n\n-   A header bar with the title\n\n-   A left-hand sidebar with the word *Sidebar*\n\n-   A main panel with the text *Main content area*\n\n🎉 That’s your first `bslib` layout up and running!\n\n![](images/step1-empty.PNG)\n\nYou can add additional elements to the main panel of the page by supplying them to `page_sidebar`.\n\nBy default, the sidebar panel will appear on the left side of your app. You can move it to the right side by giving `sidebar` the optional argument `position = \"right\"`.\n\n💻 **Try this now**\n\nIf you want to, `page_sidebar` creates a sidebar layout that fills the page, and is a quick way to create a page with a sidebar. If you’d like to create a floating sidebar layout that can appear anywhere on the page, use `page_fluid` and `layout_sidebar`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Floating sidebar layout\nui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"), # sidebar elements\n    \n   \"Main contents\" # Main pannel elements\n  )\n)\n```\n:::\n\n\n\n\n![](images/step2-fluid-page.PNG)\n\nYou'll notice here that the side bar and main contents panes are much smaller now, this is because `page_fluid()` allows the contents to scale to the required window size to fit the content.\n\nShiny also allows for more complex layouts too including options for example, `page_navbar` creates a multi-page user interface that includes a navigation bar. This layout is great for multistage analysis or reporting.\n\n![](images/navbars.PNG)\n\nAnother option for creating multipage dashbaords is through the Tabs\n\n![](images/tabs-nav.PNG)\n\nWe will stick to using a single page app today but everything we learn can be applied to controlling multipage apps in the future!\n\n## Layout Elements\n\n### `Cards()`\n\nNow we have out sidebar and main panel, we can also add containers to the main panel that will house out our data visualisations, `cards()` are a common organising unit in modern dashboards.\n\nYou can use the function `card()` to create a card in your Shiny app. `card()` creates a regular container with borders and padding.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\", \n    # including a card container in the main panel\n    card(\n      height=400 # setting the height of the card to ensure we can see it when empty.\n    )\n  )   \n)\n```\n:::\n\n\n\n\n![](images/step3-cards1.PNG)\n\nUse cards to present grouped and related information. Add content to a card by supplying arguments to `card()`.\n\nCard item functions create various different parts to the card:\n\n-   `card_header()` - A header (with border and background color) for the `card()`. Typically appears before a `card_body()`.\n\n-   `card_footer()` - A header (with border and background color) for the `card()`. Typically appears after a `card_body()`.\n\n-   `card_boady()` - A general container for the \"main content\"\n\n### Exercise 1\n\n1.  Use the above elements to add a `card_header()`, `card_footer()` and `card_body()` to our current application - **Hint:** try adding some plain text in \" \" to each of the elements.\n\n::: {.callout-tip collapse=\"true\" title=\"Show Solution\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# inclduing card elements\nui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\", \n    card(\n      height=400, #height set to 400 pixels\n      full_screen = TRUE,  #allow card to expand if full screnn button is clicked \n      card_header(\"A Header\"), # add a header\n      card_body(\"Card Body\"),  # add main body \n      card_footer(\"A Footer\")  # add footer\n    )\n  )   \n)\n```\n:::\n\n\n\n\n![](images/step3-cards2.PNG)\n:::\n\n> We'll be using `cards()` alot in this tutorial to house the elements of our dashboard. See the `bslib` [Cards article](https://rstudio.github.io/bslib/articles/cards/?_gl=1*b31cr8*_ga*MzI4NDUyMTQwLjE3MTU4NDE0Mjg.*_ga_8QJS108GF1*czE3NTAzNzY0NzckbzM5JGcxJHQxNzUwMzc2ODI1JGo0OCRsMCRoMA..*_ga_2C0WZ1JHG0*czE3NTAzNzY0NzckbzUyJGcxJHQxNzUwMzc2ODI1JGo0OCRsMCRoMA..) to learn more about cards.\n\n### `value_boxes()`\n\nValue boxes are another useful UI component. Use value boxes to highlight important values in your app.\n\nCreate a value box with the function `value_box()`.\n\nA [`value_box()`](https://rstudio.github.io/bslib/reference/value_box.html) has 4 main parts:\n\n1.  `value`: Some text value.\n\n2.  `title`: Optional text to display above `value`.\n\n3.  `showcase`: Optional UI element(s) to display alongside the value.\n\n4.  `theme`: Optional theme to change the appearance of the value box.\n\n5.  `...`: Any other text/UI elements to appear below `value`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- page_fluid(\n    layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\", \n    # including a Value Box     \n    value_box(\n      title = \"Value box\", # Title\n      value = 750          # Value to show \n      ),\n    card(\n      height=400, \n      full_screen = TRUE, \n      card_header(\"A Header\"), \n      card_body(\"Card Body\"), \n      card_footer(\"A Footer\")\n    )\n  )   \n)\n```\n:::\n\n\n\n\n![](images/step4-value-boxes.PNG)\n\nTo make our value boxes stand-out even more we can enhance their appearance through setting their theme colour and including inforgraphic icons.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n ui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\", \n    # including a Value Box     \n    value_box(\n      title = \"Value box\", # Title\n      value = 750,         # Value to show\n      showcase = bsicons::bs_icon(\"laptop\"), #include and icon\n      theme = \"pink\" # change the box theme colour\n    ),\n    card(\n      height=400, \n      full_screen = TRUE,\n      card_header(\"A Header\"), \n      card_body(\"Card Body\"), \n      card_footer(\"A Footer\")\n    )\n  )   \n)\n```\n:::\n\n\n\n\n::: callout-note\nNote: to use Bootstrap icons, use the function [`bsicons::bs_icon()`](https://rstudio.github.io/bsicons/reference/bs_icon.html)\n\nCheck out the library of avaliable icons [here](https://icons.getbootstrap.com/)\n\nWe can change the location of `value_boxes()` using the `showcase_layout()` arguement - options include `\"left center\"`, `\"top-right\"`. or `\"bottom\"`\n:::\n\n### Exercise 2\n\n2.  Add an addiditional `value_box()` and `card()` to your current dashboard. Set the `card()` to a different height and choose a new icon, theme and icon placement for the addiditional `value_box()`\n    -   **Hint:** Bootstrap's theme colors are drawn from [a second color list](https://getbootstrap.com/docs/5.3/customize/color/#all-colors) that includes variations on several main colors, named literally. These colors include `\"blue\"`, `\"purple\"`, `\"pink\"`, `\"red\"`, `\"orange\"`, `\"yellow\"`, `\"green\"`, `\"teal\"`, and `\"cyan\"`.\n\n::: {.callout-tip collapse=\"true\" title=\"Show Solution\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\", \n    value_box(\n      title = \"Value box\",\n      value = 750,\n      showcase = bsicons::bs_icon(\"laptop\"),\n      theme = \"pink\"\n    ),\n    # second value box \n    value_box(\n      title = \"Value box 2\", \n      value = 1993, \n      showcase = bsicons::bs_icon(\"calendar\"), \n      showcase_layout = \"top right\", \n      theme = \"blue\" \n    ), \n    card(\n      height=400, \n      full_screen = TRUE,\n      card_header(\"A Header\"), \n      card_body(\"Card Body\"), \n      card_footer(\"A Footer\")\n    ), \n    # second card box \n    card(\n      height = 200, \n      full_screen = TRUE,\n      card_header(\"Another Header\"), \n      card_footer(\"Another Footer\"), \n      card_body(\"Another Card\")\n    )\n  )   \n)\n```\n:::\n\n\n\n\n![](images/step5-addiditional-elements.PNG)\n:::\n\n## Adjusting Layout Positions\n\nBy default, when you add multiple elements to your main panel, Shiny will place them one after another vertically (i.e., one long column). But as we build real dashboards, we often want to organize elements *horizontally* or into *grids* to create a cleaner and more informative user interface.\n\nThis is where layout functions like `layout_columns()` and `layout_column_wrap()` come in.\n\n### `layout_columns()`\n\nThe function `layout_columns()` allows you to place elements next to each other, specifying how many columns wide each element should be. Shiny divides the available space into 12 columns . You can assign any number of columns to each element, as long as they add up to 12 or less.\n\nLet’s try adding moving our two value boxes side by side:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\", \n    \n    # two column value boxes\n    layout_columns(\n      value_box(\n      title = \"Value box\",\n      value = 750,\n      showcase = bsicons::bs_icon(\"laptop\"),\n      theme = \"pink\"\n      ),\n   \n    value_box(\n      title = \"Value box 2\", \n      value = 1993, \n      showcase = bsicons::bs_icon(\"calendar\"), \n      showcase_layout = \"top right\", \n      theme = \"blue\" \n      ), \n    ), \n    \n    card(\n      height=400,  \n      full_screen = TRUE,\n      card_header(\"A Header\"), \n      card_body(\"Card Body\"), \n      card_footer(\"A Footer\")\n    ), \n  \n    card(\n      height = 200,  \n      full_screen = TRUE,\n      card_header(\"Another Header\"), \n      card_footer(\"Another Footer\"), \n      card_body(\"Another Card\")\n    )\n  )   \n)\n```\n:::\n\n\n\n\n![](images/layout-cols1.PNG)\n\n`layout_columns()` automatically places the two value boxes next to each other. By default, each element inside `layout_columns()` takes up equal space. If you want more control, you can specify `col_widths` for each element /12 e.g. ``` col_widths``= c(6, 6) ```.\n\n### Exercise 3\n\n3.  Use `layout_columns()` to set the `card()` elements into two columns. What do you notice about the height of the cards?\n\n::: {.callout-tip collapse=\"true\" title=\"Show Solution\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\", \n    \n    # two column value boxes\n    layout_columns(\n      value_box(\n        title = \"Value box\",\n        value = 750,\n        showcase = bsicons::bs_icon(\"laptop\"),\n        theme = \"pink\"\n      ),\n      \n      value_box(\n        title = \"Value box 2\", \n        value = 1993, \n        showcase = bsicons::bs_icon(\"calendar\"), \n        showcase_layout = \"top right\", \n        theme = \"blue\" \n      ), \n    ), \n    \n    layout_columns(\n      card(\n        height=400,  \n        full_screen = TRUE,\n        card_header(\"A Header\"), \n        card_body(\"Card Body\"), \n        card_footer(\"A Footer\")\n      ), \n      \n      card(\n        height = 200, \n        full_screen = TRUE, \n        card_header(\"Another Header\"), \n        card_footer(\"Another Footer\"), \n        card_body(\"Another Card\")\n      )\n    )\n    \n  )   \n)\n```\n:::\n\n\n\n\nThe two cards are now the same height as the tallest card. This is because `layout_columns()` automatically sets the height of each column to match the tallest element in that row.\n\n![](images/layout-cols2.PNG)\n:::\n\n### `layout_column_wrap()`\n\nIf you have many elements and want them to automatically wrap onto multiple rows (like a responsive grid), you can use `layout_column_wrap()`.\n\nFor example, you might want to display six value boxes, but have them wrap automatically depending on screen size:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\", \n    \n    # adding layout_column_wrap for automatic wrapping\n    layout_column_wrap(\n      value_box(\n        title = \"Value box\",\n        value = 750,\n        showcase = bsicons::bs_icon(\"laptop\"),\n        theme = \"pink\"\n      ),\n      \n      value_box(\n        title = \"Value box 2\", \n        value = 1993, \n        showcase = bsicons::bs_icon(\"calendar\"), \n        showcase_layout = \"top right\", \n        theme = \"blue\" \n      ), \n      # addiditional boxes\n      value_box(\n        title = \"Value box 3\", \n        value = 123\n      ), \n      value_box(\n        title = \"Value box 4\", \n        value = 456\n      ), \n      value_box(\n        title = \"Value box 5\", \n        value = 789,\n        \n      ), \n      value_box(\n        title = \"Value box 6\", \n        value = 101112,\n      ), \n    ), \n    \n    layout_columns(\n      card(\n        height=400, \n        full_screen = TRUE,\n        card_header(\"A Header\"), \n        card_body(\"Card Body\"), \n        card_footer(\"A Footer\")\n      ), \n      \n      card(\n        height = 200,\n        full_screen = TRUE,\n        card_header(\"Another Header\"), \n        card_footer(\"Another Footer\"), \n        card_body(\"Another Card\")\n      )\n    )\n    \n  )   \n)\n```\n:::\n\n\n\n\n![](images/layout-cols3.PNG){fig-align=\"left\"}\n\n![](images/layout-cols4.PNG){fig-align=\"right\"}\n\nThis makes your app much more responsive: as users resize their browser window, the layout adjusts automatically.\n\n## Widget Control Elements\n\nNow that we’ve set up a clean layout using `bslib`, let’s add some interactive functionality, the sidebar is where we direct the user to select inputs the will send messages to the Shiny app. Shiny widgets collect a value from your user. When a user changes the widget, the value will change as well.\n\n### Choosing the Right Input controls: A Quick Exploration\n\nBefore we add our first user input, it’s helpful to understand a few common types of **control widgets** in Shiny and when to use them. Inputs allow users to interact with the webpage by clicking a button, entering text, selecting an option, and more.\n\nShiny provides [several ways](https://shiny.posit.co/r/components/) for users to make selections here are a couple of options:\\\n\n| Input Type | Function | When to Use |\n|------------------------|------------------------|------------------------|\n| [Dropdown menu](https://shiny.posit.co/r/components/inputs/select-single/) | `selectInput()` | ✅ Best for **long lists** — compact and searchable |\n| [Radio buttons](https://shiny.posit.co/r/components/inputs/radio-buttons/) | `radioButtons()` | ✅ Best for **short lists** with a few clear options (e.g., Yes/No, 3-4 choices) |\n| [Checkbox group](https://shiny.posit.co/r/components/inputs/checkbox/) | `checkboxGroupInput()` | ✅ Best for selecting **multiple options** |\n| [Autocomplete select](https://shiny.posit.co/r/components/inputs/selectize-single/) | `selectizeInput()` | ✅ Similar to `selectInput()`, but includes **type-ahead search** by default |\n| [Single checkbox](https://shiny.posit.co/r/components/inputs/checkbox/) | `checkboxInput()` | ✅ Best for simple **on/off**, **true/false** inputs |\n| [Slider](https://shiny.posit.co/r/components/inputs/slider/) | `sliderInput()` | ✅ Best for selecting **continuous values** or **ranges** |\n| [Numeric input](https://shiny.posit.co/r/components/inputs/numeric-input/) | `numericInput()` | ✅ Best for **precise numeric entry** |\n| [Text input](https://shiny.posit.co/r/components/inputs/text-area/) | `textAreaInput()` | ✅ Best for **free text entry** (e.g. names, IDs, labels) |\n| [Date input](https://shiny.posit.co/r/components/inputs/date-selector/) | `dateInput()` | ✅ Best for selecting a **single date** |\n| [Date range input](https://shiny.posit.co/r/components/inputs/date-range-selector/) | `dateRangeInput()` | ✅ Best for selecting a **start and end date** |\n| [File upload](https://shiny.posit.co/r/components/inputs/file-input/) | `fileInput()` | ✅ Best for allowing users to **upload files** |\n| [Action button](https://shiny.posit.co/r/components/inputs/action-button/) | `actionButton()` | ✅ Best for triggering **explicit actions** (e.g. submit, run model) |\n\nEach widget function requires several arguments. The first two arguments for each widget are\n\n-   a **name for the widget**: The user will not see this name, but you can use it to access the widget’s value. The name should be a character string.\n\n-   a **label**: This label will appear with the widget in your app. It should be a character string, but it can be an empty string `\"\"`.\n\nIn this example, the name is “action” and the label is “Action”: `actionButton(\"action\", label = \"Action\")`\n\nThe remaining arguments vary from widget to widget, depending on what the widget needs to do its job. They include things like initial values, ranges, and increments. You can find the exact arguments needed by a widget on the widget function’s help page, (e.g., `?selectInput`).\n\n### Exercise 4\n\n4.  For our dashboard, we want to be able to select a single province to display our data - lets test out some of these examples above and select the most appropriate option for our dashboard.\n\nReplace your `sidebar` code with the following:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsidebar = list(\n  p(\"Test different input styles. Which one works best for selecting a province from a long list?\"),\n\n  selectInput(\n    inputId = \"dropdown_test\", # ID name that can pass to the server as input$dropdown_test for processing\n    label = \"Dropdown input (selectInput):\", # Title the user sees on the UI\n    choices = sort(unique(app_data$organisation_unit)) # values to shown in the list drawn from all the unit names in our dataset\n  ),\n\n  radioButtons(\n    inputId = \"radio_test\",\n    label = \"Radio buttons (radioButtons):\",\n    choices = sort(unique(app_data$organisation_unit))\n  ),\n\n  checkboxGroupInput(\n    inputId = \"checkbox_test\",\n    label = \"Checkbox group (checkboxGroupInput):\",\n    choices = sort(unique(app_data$organisation_unit))\n  )\n)\n```\n:::\n\n\n\n\n> Reflect:\n>\n> -   What happens when the list is long?\n>\n> -   Which is more space-efficient?\n>\n> -   What would help users most?\n\n::: {.callout-tip collapse=\"true\" title=\"Show Solution\"}\nFor this app, we’ll use `selectInput()` because:\n\n-   We have many provinces to choose from\n\n-   We only need one selection at a time\n\n-   It’s clean, compact, and familiar\n:::\n\n## Putting it all together\n\nLets now create the skeleton of our dashboard. Firstly what we want to be able to do is allow user to select a **Province**.\n\nWe’ll start by updating the **UI** to add a control widget that selects for province and in Part 2 we will address adding reactive elements to our output containers.\n\nLet’s now update the sidebar to add a proper dropdown input for Province selection. Remember to ensure we are reading in our dataset prior to the UI and Server code.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\n      # Add user input selection \n      p(\"User Inputs\"),\n      selectInput(\n        inputId = \"province_select\",  # ID value\n        label = \"Select a Province:\", # UI side Title\n        choices = c(\"\", sort(unique(app_data$organisation_unit))), # empty first value followed by all of our unique org_unit names\n        selected = \"\" # default value that the application starts with as selected - in our case we want this to be blank. \n      )\n    ),\n    \n    # Main content\n    \"Main contents\", \n    \n    # value boxes wrapped automatically\n    layout_column_wrap(\n      value_box(\n        title = \"Value box\",\n        value = 750,\n        showcase = bsicons::bs_icon(\"laptop\"),\n        theme = \"pink\"\n      ),\n      \n      value_box(\n        title = \"Value box 2\", \n        value = 1993, \n        showcase = bsicons::bs_icon(\"calendar\"), \n        showcase_layout = \"top right\", \n        theme = \"blue\" \n      ), \n      value_box(title = \"Value box 3\", value = 123), \n      value_box(title = \"Value box 4\", value = 456), \n      value_box(title = \"Value box 5\", value = 789), \n      value_box(title = \"Value box 6\", value = 101112)\n    ), \n    \n    # two cards side-by-side\n    layout_columns(\n      card(\n        height = 400,  \n        full_screen = TRUE,\n        card_header(\"A Header\"), \n        card_body(\"Card Body\"), \n        card_footer(\"A Footer\")\n      ), \n      \n      card(\n        height = 200, \n        full_screen = TRUE,\n        card_header(\"Another Header\"), \n        card_footer(\"Another Footer\"), \n        card_body(\"Another Card\")\n      )\n    )\n  )   \n)\n```\n:::\n\n\n\n\n**What this is doing:**\n\n| Function/Argument | Description |\n|------------------------------------|------------------------------------|\n| `selectInput()` | Adds a dropdown input where users can choose a Province |\n| `inputId = \"province_select\"` | This ID connects the UI to the server logic (we’ll use it in Part 2) |\n| `choices = ...` | Pulls all Province names from the dataset and sorts them alphabetically |\n| `selected = NULL` | No Province is pre-selected when the app first loads |\n\n![](images/user-inputs1.PNG)\n\n## Pause & Reflect: Where We Are\n\nBefore we move forward, take a quick moment to review what you’ve built so far:\n\n✅ You’ve created your own Shiny app from scratch.\n\n✅ You set up a modern dashboard layout using `bslib::page_fluid()` and `layout_sidebar()`\n\n✅ You’ve learned how to organize content using:\n\n-   `card()` to hold your future plots and tables\n\n-   `value_box()` to display key summary indicators\n\n-   `layout_columns()` and `layout_column_wrap()` to control the page structure\n\n✅ You’ve explored how to place **interactive control widgets** into the sidebar using `selectInput()`, which will allow users to filter the data.\n\n### Quick self-check questions\n\n-   Do you understand the difference between **UI** and **Server** parts of the app?\n\n-   Can you identify where the user interacts (inputs) vs where outputs will be displayed?\n\n-   Do you feel comfortable adding more cards, value boxes, or inputs to your app?\n\n# Part 2 Reactivty and Rendering output\n\nIn Part 2, you will learn:\n\n-   How to add display elements into the dashbaord cards.\n\n-   How to connect your `selectInput()` dropdown to your dataset.\n\n-   How to filter data reactively based on user selections.\n\n-   How to update your value boxes and outputs automatically when the user interacts.\n\nIn Shiny, **reactive expressions** automatically update when the user interacts with your app.\n\n## Shiny Output Types\n\nYou can create reactive outputs with a two step process.\n\n1.  Add an R object to your user interface.\n\n2.  Tell Shiny how to build the object in the server function. The object will be reactive if the code that builds it calls a widget value.\n\nShiny provides a [family of functions](https://shiny.posit.co/r/components/) that turn R objects into output for your user interface. Each function creates a specific type of output.\n\n![](images/shiny-output-types.PNG)\n\nBelow is a summary of some key output types, the functions to tell shiny what the expect in the UI and the functions to create it in the server and a short desciption of when to use.\n\n| Output Type | Render Function (Server) | Display Function (UI) | When to Use |\n|------------------|------------------|------------------|------------------|\n| **Text** | `renderText()` | `textOutput()` | Display simple text strings |\n| **Tables (static)** | `renderTable()` | `tableOutput()` | Show small static tables |\n| **Tables (interactive)** | `renderDT()` | `DT::dataTableOutput()` | Show sortable, searchable tables |\n| **Plots (static)** | `renderPlot()` | `plotOutput()` | Standard static plots (ggplot, base R plots) |\n| **Plots (interactive)** | `renderPlotly()` | `plotlyOutput()` | Fully interactive plots (hover, zoom, pan) |\n| **Leaflet Maps** | `renderLeaflet()` | `leafletOutput()` | Interactive geographic maps |\n| **Images** | `renderImage()` | `imageOutput()` | Display image files (PNG, JPG, etc.) |\n| **UI elements** (dynamic) | `renderUI()` | `uiOutput()` | Dynamically generate any custom UI |\n| **Value Boxes** | *(no render function)* | `value_box()` | Display single KPI summary values |\n\n> What you will notice is that Every output type has:\n>\n> -   **One render function** → goes in the server\n>\n> -   **One output function** → goes in the UI\n\nAnd you connect them using a shared `outputId`\n\n## Building Reactive Outputs: `ui` and `server` crosstalk\n\nLets work through an example to display the Province that the user selected in the first card of our current dashboard.\\\nWe want to show some text that says:\n\n> *\"You have selected: \\[Province\\]\"*\n\nTo do this, we add `textOutput()` to the UI where we want the text to appear,in this instance we add it to the `card_body()` call.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\n      p(\"User Inputs\"),\n      selectInput(\n        inputId = \"province_select\",  \n        label = \"Select a Province:\",\n        choices = c(\"\", sort(unique(app_data$organisation_unit))),\n        selected = \"\" \n      )\n    ),\n    \n    \"Main contents\", \n    \n    layout_column_wrap(\n      value_box(\n        title = \"Value box\",\n        value = 750,\n        showcase = bsicons::bs_icon(\"laptop\"),\n        theme = \"pink\"\n      ),\n      \n      value_box(\n        title = \"Value box 2\", \n        value = 1993, \n        showcase = bsicons::bs_icon(\"calendar\"), \n        showcase_layout = \"top right\", \n        theme = \"blue\" \n      ), \n      value_box(title = \"Value box 3\", value = 123), \n      value_box(title = \"Value box 4\", value = 456), \n      value_box(title = \"Value box 5\", value = 789), \n      value_box(title = \"Value box 6\", value = 101112)\n    ), \n    \n    layout_columns(\n      card(\n        height = 400,  \n        full_screen = TRUE,\n        card_header(\"A Header\"), \n        card_body(\n          textOutput(\"selected_province_text\") # add textOutput to display selected province\n        ), \n        card_footer(\"A Footer\")\n      ), \n      \n      card(\n        height = 200,  \n        full_screen = TRUE,\n        card_header(\"Another Header\"), \n        card_footer(\"Another Footer\"), \n        card_body(\"Another Card\")\n      )\n    )\n  )   \n)\n```\n:::\n\n\n\n\n::: callout-note\nNotice that `textOutput` takes an argument, the character string `\"selected_province_text\"`. Each of the `*Output` functions require a single argument: a character string that Shiny will use as the name of your reactive element. Your users will not see this name, but you will use it later.\n:::\n\nPlacing a function in `ui` tells Shiny where to display your object. Next, you need to tell Shiny how to build the object.\n\nWe do this by providing the R code that builds the object in the `server` function.\n\nThe `server` function plays a special role in the Shiny process; it builds a list-like object named `output` that contains all of the code needed to update the R objects in your app. Each R object needs to have its own entry in the list.\n\nYou can create an entry by defining a new element for `output` within the `server` function, like below. The element name should match the name of the reactive element that you created in the `ui`.\n\nIn the `server` function below, `output$selected_province_text` matches `textOutput(\"selected_province_text` `\")` in your `ui`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output) {\n  \n  output$selected_province_text <- renderText({\n    # If nothing is selected, show a default message\n    if (input$province_select == \"\") {\n      \"No Province Selected\"\n    } else {\n    # otherwise show the selected value\n      paste(\"You have selected:\", input$province_select)\n    }\n  })\n  \n}\n```\n:::\n\n\n\n\n`input` is a second list-like object created by the server function. It stores the current values of all of the widgets in your app. These values will be saved under the names that you gave the widgets in your `ui`.\n\nSo for example, our app has one widget, one named `\"province_select\"` .The values of `\"province_select\"` will be saved in `input` as `input$province_select`.\n\nShiny will automatically make an object reactive if the object uses an `input` value. For example, the `server` function above creates a reactive line of text by calling the value of the select box widget to build the text.\n\n![](images/text-reactive.PNG)\n\nWhen the user changes the province name the text outoput will update automatically - try this out.\n\n**What you just learned:**\n\n| Part   | Code                                                   |\n|--------|--------------------------------------------------------|\n| UI     | `textOutput(\"selected_province_text\")`                 |\n| Server | `output$selected_province_text <- renderText({ ... })` |\n| Link   | Both use the same ID: `\"selected_province_text\"`       |\n\nEach entry to `output$ <-` should contain the output of one of Shiny’s `render*` functions. These functions capture an R expression and do some light pre-processing on the expression. Use the `render*` function that corrresponds to the type of reactive object you are making (Pairs are listed in the table above).\n\nEach `render*` function takes a single argument: an R expression surrounded by braces, `{}`. The expression can be one simple line of text, or it can involve many lines of code, as if it were a complicated function call.\n\nThink of this R expression as a set of instructions that you give Shiny to store for later. Shiny will run the instructions when you first launch your app, and then Shiny will re-run the instructions every time it needs to update your object.\n\nFor this to work, your expression should return the object you have in mind (a piece of text, a plot, a data frame, etc.). You will get an error if the expression returns the wrong type of object.\n\n## Reactivity and Data\n\nIn the previous step our app simply reacts to the user input and displays the Province - now we want to also tell our App to do more with that information by filtering and displaying summary data from our DHIS2 data pull.\n\nWe want to compute (for now, keep it simple):\n\n-   Total number of malaria cases reported in the selected province for the year\n\nWe know our dataset is called `app_data`, and malaria cases are stored where `var_name == \"malaria_cases\"`.\n\nInside your `server()` function, add:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output) {\n  \n  # Reactive data filter - filter the app_data when input value is selected\n  province_data <- reactive({\n    req(input$province_select != \"\")  # Only run if province selected\n    \n    app_data %>% \n      filter(organisation_unit == input$province_select) # filter dataset to Province selected\n  })\n  \n  # Compute total cases from filtered data\n  output$total_cases_box <- renderText({\n    df <- province_data() # this act like a function and pulls through our filtered data to an object inside renderText called 'df'\n    \n    total_cases <- df %>%\n      filter(var_name == \"malaria_cases\") %>% # filters to malaria cases data only\n      summarise(total = sum(value, na.rm = TRUE)) %>% # sums values over all periods included\n      pull(total) # pulls out the value from summary calculation into named vector\n    \n    total_cases # final value\n  })\n}\n```\n:::\n\n\n\n\nHere we have made our `province_data()` object *reactive* - what this means is that every time `input$province_select` changes, Shiny will automatically re-execute any code that depends on `province_data()`.\n\nWe use the filtered `province_data()` in the `output$total_cases_box` to then create a single value of total cases reported that year.\n\nWe’re using `renderText()` as our server side output function - we need to feed this information to our updated `value_box()` UI code next.\n\nWe want to replace the `value` argument with the dynamic text from our server `\"total_cases_box\"`. In your `ui`, replace the original value box with:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  value_box(\n        title = \"Total Cases Reported\",\n        value =  textOutput(\"total_cases_box\"), # reactive value taken from server side outputs\n        showcase = bsicons::bs_icon(\"journal-medical\"),\n        showcase_layout = \"top right\", \n        theme = \"pink\"\n      )\n```\n:::\n\n\n\n\n![](images/reactive-value-box.PNG)\n\n**Summary of updates**\n\n|                  |                                                 |\n|------------------|-------------------------------------------------|\n| Reactive filter  | `province_data <- reactive({ ... })`            |\n| Computation      | `summarise()` inside `renderText()`             |\n| Output rendering | `output$total_cases_box <- renderText({ ... })` |\n| UI linkage       | `value = textOutput(\"total_cases_box\")`         |\n\n### Exercise 5\n\n5.  Update the second value box to compute and display total annual tests (`var_name == \"malaria_tests\"`), update the icon to match the data reporting type, and remove the remaining value boxes for now,\n\n::: {.callout-tip collapse=\"true\" title=\"Show Solution\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# update the value box to contain a renderOutput call\n value_box(\n        title = \"Total Tests Reported\", \n        value = textOutput(\"total_tests_box\"), #render output call\n        showcase = bsicons::bs_icon(\"journal-medical\"), # update icon\n        showcase_layout = \"top right\", \n        theme = \"blue\" \n      )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n # Compute total tests from filtered data\n  output$total_tests_box <- renderText({\n    df <- province_data() # pull filtered province data\n    \n    total_tests <- df %>%\n      filter(var_name == \"malaria_tests\") %>%\n      summarise(total = sum(value, na.rm = TRUE)) %>% #sum total tesats\n      pull(total)\n    \n    total_tests # return value\n  })\n```\n:::\n\n\n\n\n![](images/value-box-exercises.PNG)\n:::\n\nGood job! We'll come back to our value boxes later to add more functionality, but for now let's focus on adding a time series plot to visualize the malaria cases over time.\n\n## Adding a Reactive Plot\n\nNow that we have our value boxes displaying total cases and tests, let’s add a time series plot to visualize malaria cases over time for the selected Province.\n\nWe’ll use: `plotlyOutput()` in our UI card to reserve a space for an interactive chart.\n\nLets update one of our existing cards to include a plotly output.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlayout_columns(\n       card(\n        height = 400, \n        full_screen = TRUE,\n          card_header(\"Monthly Confirmed Malaria Cases\"),\n          card_body(plotlyOutput(\"ts_plot\")), # include plotlyOutput in the card body and name this output ts_plot\n          card_footer(\"Data source: DHIS2 export\")\n        ), \n       \n       #....\n)\n```\n:::\n\n\n\n\nThis creates a card with a header, a plotly output area, and a footer. The `plotlyOutput(\"ts_plot\")` is where our time series plot will go.\n\nNow that we’ve created a space for our plot in the UI, it’s time to write the **server-side logic** that:\n\n2.  Creates a time series plot of malaria cases\n\n3.  Displays that plot inside the `ts_plot` output that we just specified\n\nAdd the following code to the `server` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#-Server - Server Logic---------------------------------------------------------\nserver <- function(input, output, session) {\n    \n  \n  # ... current code\n  \n  # Render the interactive time series plot \n  # Make the plot using GGplot and use Plotly to make it interactive\n  output$ts_plot <- \n    renderPlotly({\n      df <- province_data()  |>  # get province data\n        filter(var_name == \"malaria_cases\") # reduce to cases\n      \n      req(nrow(df) > 0)              # Ensure there are rows to plot\n      \n      # Create a ggplot time series of time va cases\n      p <- ggplot(df, aes(x = period, y = value)) +\n        geom_line() +\n        geom_point() + \n        labs(\n          title = paste(\"Confirmed Malaria Cases in:\", input$province_select), # ass selected province to the title\n          x = \"Month\",\n          y = \"Confirmed Cases\"\n        ) +\n        theme_minimal()\n      \n      # Convert ggplot to interactive Plotly object\n      ggplotly(p)\n    })\n}\n```\n:::\n\n\n\n\nWhat this is doing:\n\n-   `renderPlotly()`: Tells Shiny how to render the `plotlyOutput()` in the UI\n\n-   `ggplot()`: creates a time series plot with `geom_line()` to show the trend of confirmed cases over time.\n\n-   `ggplotly()`: converts the ggplot object to a Plotly object for interactivity.\n\n**Test It**\n\nRun your app and try the following:\n\n-   Select a Province from the dropdown\n\n-   Watch the plot appear in the card\n\n-   Hover over points to see values\n\n-   Try selecting a different Province, the plot updates automatically!\n\n::: callout-note\n📊 [Plotly](https://plotly.com/r/) **for Interactive Plots**\n\nThe [Plotly](https://plotly.com/r/) package allows you to turn static `ggplot2` charts into interactive visualizations. This means users can **hover over points**, **zoom in**, **pan across the plot**, and **see tooltips** with data values.\n\nIn Shiny, this is especially useful for dashboards where you want dynamic, user-driven exploration of your data.\n\nWe use the `ggplotly()` function to **convert a regular `ggplot` object into a Plotly object**, making it fully interactive with minimal changes to your code.\n\nJust remember that not all `ggplot2` features translate perfectly, some customization may require testing or tweaking. Or you can always build plots directly using Plotly code but for now we'll stick with ggplot \\> ploty conversion.\n:::\n\n### Exercise 6 -7:\n\n> 1.  Modify the plot to include both confirmed cases and malaria tests as two lines (different colors). **Hint: check back in your DHIS2 extraction slides for an example plotting multiple indicators**. **Hint: edit the `var_name %in% c()`filter to select both indicators.** Once rendered plotly has an option to view both hover labels at the same time - see if you can make this work in your local app.\n\n::: {.callout-tip collapse=\"true\" title=\"Show Solution\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n card(\n        height = 400, \n        full_screen = TRUE,\n          card_header(\"Monthly Malaria Indicators\"), # change headeras we have multiple indicators now \n          card_body(plotlyOutput(\"ts_plot\")),\n          card_footer(\"Data source: DHIS2 export\")\n        )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n  output$ts_plot <- \n    renderPlotly({\n      df <- province_data()  |> \n        filter(var_name %in% c(\"malaria_cases\", \"malaria_tests\")) # Include tests in filter\n      \n      req(nrow(df) > 0)              # Ensure there are rows to plot\n      \n      # Create a ggplot time series\n      p <- ggplot(df, aes(x = period, y = value, col=var_name)) + # add colour arguement to distinguish data points\n        geom_line() +\n        geom_point()+\n        labs(\n          title = paste(\"Malaria Cases in:\", input$province_select),\n          x = \"Month\",\n          y = \"Value\", \n          color = \"Indicator Variable\"\n        ) + \n        scale_color_manual(values = c(\"malaria_cases\" = \"#571845\", \"malaria_tests\" = \"#C42847\"))+ # set the colour values\n        theme_minimal()\n      \n      # Convert ggplot to interactive Plotly object\n      ggplotly(p)\n    })\n```\n:::\n\n\n\n\n![](images/double-line-plot.PNG)\n:::\n\n> 2.  Add a new input selection that lists the two data elements (“confirmed cases”, “malaria tests”) so users can toggle which series appear. Hint use: [`checkboxGroupInput()`](https://shiny.posit.co/r/reference/shiny/1.7.4/checkboxgroupinput.html) to allow multiple selections to be toggeled on and off. **Hint** think carefully about how to use the new `input$` value to filter the dataset.\n\n::: {.callout-tip collapse=\"true\" title=\"💡 Show Solution\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsidebar = sidebar(\n      p(\"User Inputs\"),\n      selectInput(\n        inputId = \"province_select\",  \n        label = \"Select a Province:\",\n        choices = c(\"\", sort(unique(app_data$organisation_unit))),\n        selected = \"\" \n      ), \n      # <<< NEW >>> checkbox group input\n      checkboxGroupInput(\n        inputId = \"series_select\", # give usable ID\n        label = \"Select data series:\", # UI side title\n        choices = c(\"Confirmed Cases\" = \"malaria_cases\", # filter variables with nice formatting for the UI\n                    \"Malaria Tests\"  = \"malaria_tests\"),\n        selected = NULL\n      )\n    )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noutput$ts_plot <- \n    renderPlotly({\n      df <- province_data()  |> \n        filter(var_name %in% input$series_select) # Get the filtered data as per input\n      \n      req(nrow(df) > 0)              # Ensure there are rows to plot\n      \n      # Create a ggplot time series\n      p <- ggplot(df, aes(x = period, y = value, col=var_name)) +\n        geom_line() +\n        geom_point()+\n        labs(\n          title = paste(\"Malaria Cases in:\", input$province_select),\n          x = \"Month\",\n          y = \"Value\", \n          color = \"Indicator Variable\"\n        ) + \n        scale_color_manual(values = c(\"malaria_cases\" = \"#571845\", \"malaria_tests\" = \"#C42847\"))+\n        theme_minimal()\n      \n      # Convert ggplot to interactive Plotly object\n      ggplotly(p)\n    })\n```\n:::\n\n\n\n\n![](images/double-line-plot2.PNG)\n:::\n\n## End of Part 2 — What You’ve Built So Far\n\n✅ You now have a fully **reactive dashboard skeleton**:\n\n-   **Inputs**: User selects a Province and which data series to view.\n\n-   **Reactive filtering**: The app filters the dataset automatically.\n\n-   **Outputs**:\n\n    -   Value boxes update in real-time\n\n    -   Interactive time series plots update dynamically\n\n    -   You’ve seen how both text-based and graphical outputs follow the same reactivity pattern.\n\n# Part 3: Evolving Features - Making Our App Better!\n\nNow that we’ve built the basic functionality of our dashboard, let’s improve the **user experience**, visual polish and ensure that all cards and value boxes contain useful information to the end-user.\n\nFirstly here are small enhancements that go a long way in making your app more intuitive, accessible, and navigable for the user.\n\n## Adding messages and prompts 📧\n\nWhen we first launch the app, the dashboard appears blank until a user selects a Province and at least one data series. While this is expected, it might not be intuitive for users who are unfamiliar with how the app works.\n\nTo improve the user experience, we can **add helpful messages** that appear when required inputs are missing. This kind of feedback, often referred to as **conditional UI messaging**, helps guide users through the app and ensures they understand what to do next.\n\nWe’ll use the `validate()` and `need()` functions from Shiny to conditionally display informative prompts *in place of a plot* until the required input is provided.\n\nTo do this we can add the following code to the top of all of our server code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# value boxes \n# Compute total cases from filtered data\noutput$total_cases_box <- renderText({\n   \n # condiditional messaging -  Check if province selection is made and if not display the following message \n   validate(\n    need(input$province_select != \"\", \"Select a province\"),\n    )\n     # ...\n}) \n\n# Compute total tests from filtered data\noutput$total_tests_box <- renderText({\n  \n  # condiditional messaging -  Check if province selection is made and if not display the following message \n  validate(\n    need(input$province_select != \"\", \"Select a province\"),\n    )\n  \n  # ...\n})\n    \n\n\n# plot cards\noutput$ts_plot <- renderPlotly({\n# Check if province and series selections are made and if not display the following messages - this ensures no error messages are thrown if data is not yet selected\n  validate(\n    need(input$province_select != \"\", \"Please select a province to view data.\"),\n    need(length(input$series_select) > 0, \"Please select at least one data elemtent to generate the plot.\")\n  )\n\n  # ...\n \n})\n```\n:::\n\n\n\n\n**What This Does:**\n\n-   **`validate()`** Tells Shiny to check conditions before rendering output\n\n-   **`need()`** Provides a custom message that is shown in the output space when a condition isn’t met.\n\n-   These messages appear in the **same area where the plot would go**, giving users immediate, contextual guidance.\n\n![](images/user-message-conditional.PNG)\n\n## Adding a Short Description of the Application 🖊️\n\nAs we continue to improve the user experience, it’s helpful to provide some **context or instructions** directly in the app. One simple but effective enhancement is adding a short **descriptive text** at the top of the sidebar panel and a Title to the main plot output.\n\nThis gives users a quick overview of what the tool does, what the inputs mean, or what they should expect to see - without needing to refer to an external guide.\n\n### Exercise 8\n\n8.  In your `ui` replace the `p(\"User Inputs\")` with a more informative description. And add a main title to replace `\"Main contents\"` . **Hint** use the function `h1(\" \")` to add your title as this will give it a Header level 1 style.\n\n::: {.callout-tip collapse=\"true\" title=\"Show Solution\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsidebar = list(\n    \n  # App description\n   p(\"Dashboard for examining province level malaria indicators in Laos.\n         Select a province and data series to view the trends over time.\"),\n    \n   # The rest of our code ...\n    \n)\n\n# Title \nh1(\"Malaria Indicator Dashboard\")\n```\n:::\n\n\n\n\n**What This Does:**\n\n-   The `p()` function inserts a paragraph of plain text at the top of the sidebar.\n\n-   This lightweight description gives users quick context about what they’re seeing and how to interact with the app.\n\n![](images/title-enhancements.PNG)\n:::\n\n::: callout-tip\\\nKeep this description short and scannable. If you want to include more detailed information (e.g., methodology or indicator definitions), we could use a [collapsible help text](https://rstudio.github.io/bslib/reference/accordion.html), a [modal popup](https://shiny.posit.co/r/reference/shiny/1.6.0/modaldialog.html), or a [separate “About” tab](https://shiny.posit.co/r/layouts/tabs/) - we'll suggest some resources for this later in the tutorial.\n:::\n\n## Theming with `bs_theme` 🎨\n\nUntil now, our dashboard has been using the **default Shiny style:** functional,but plain and we added colour values to our `value_box`. We can now take advantage of the [`bslib`](https://rstudio.github.io/bslib/) package to apply **modern, responsive theming** with just a few lines of code (via [bootswatch](https://bootswatch.com/default/)).\n\nApplying a theme makes your app easier to use, improves readability, and gives it a more professional look - especially useful when sharing with stakeholders or integrating into your organization’s brand.\n\nWe can tell our app directly to use a built-in theme in the `UI` code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nui <- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\n      \n      \n      p(\"Dashboard for examining province level malaria indicators in Laos.\n         Select a province and data series to view the trends over time.\"),\n      \n      selectInput(\n        inputId = \"province_select\",  \n        label = \"Select a Province:\",\n        choices = c(\"\", sort(unique(app_data$organisation_unit))),\n        selected = \"\" \n      ), \n      \n      checkboxGroupInput(\n        inputId = \"series_select\",\n        label = \"Select data series:\",\n        choices = c(\"Confirmed Cases\" = \"malaria_cases\",\n                    \"Malaria Tests\"  = \"malaria_tests\"),\n        selected = NULL\n      )\n    ),\n    \n    h1(\"Malaria Indicator Dashboard\"), \n    \n    layout_column_wrap(\n      value_box(\n        title = \"Total Cases Reported\",\n        value =  textOutput(\"total_cases_box\"),,\n        showcase = bsicons::bs_icon(\"journal-medical\"),\n        showcase_layout = \"top right\", \n        theme = \"pink\"\n      ),\n      \n      value_box(\n        title = \"Total Tests Reported\", \n        value = textOutput(\"total_tests_box\"),\n        showcase = bsicons::bs_icon(\"calendar\"), \n        showcase_layout = \"top right\", \n        theme = \"blue\" \n      ), \n      # hide the empty value boxes\n      # value_box(title = \"Value box 3\", value = 123), \n      # value_box(title = \"Value box 4\", value = 456), \n      # value_box(title = \"Value box 5\", value = 789), \n      # value_box(title = \"Value box 6\", value = 101112)\n    ), \n    \n    layout_columns(\n      card(\n        height = 400,  \n        full_screen = TRUE,\n          card_header(\"Monthly Malaria Indicators\"),\n          card_body(plotlyOutput(\"ts_plot\")),\n          card_footer(\"Data source: DHIS2 export\")\n        ), \n      \n      card(\n        height = 200,\n        full_screen = TRUE, \n        card_header(\"Another Header\"), \n        card_footer(\"Another Footer\"), \n        card_body(\"Another Card\")\n      )\n    ), \n  ),   \n  # <<< NEW >>> Defining the theme of your app \n  theme = bs_theme(\n    version = 5,                       # Use Bootstrap 5\n    bootswatch = \"cyborg\",             # Choose a Bootswatch theme\n    base_font = font_google(\"Roboto\")  # Optional: use a modern font\n  )\n)\n```\n:::\n\n\n\n\n![](images/theme-change.PNG)\n\n### Exercise 9\n\n9.  Try replacing `\"cyborg\"` with other [Bootswatch themes](https://bootswatch.com/) like `\"cosmo\"`, `\"journal\"`, `\"sandstone\"`, `\"minty\"`, or `\"darkly\"`.\n\nYou can also try out styles **live inside your app** using `bs_themer()`. To use it, just call `bs_themer()` once inside your `server()` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserver <- function(input, output) {\n  \n  bs_themer()\n  \n  # The rest of our code ... \n  \n} \n```\n:::\n\n\n\n\n![](images/theme-customiser.PNG)\n\nAs well as experimenting with pre-built themes you can also customise your own theming using the `bs_themer` for example if I played around in the theming and decided I wanted to use some colours similar to the AMMnet branding I could do this and then in my R console `bs_themer` lets us know what we changed and then we can add this to our `theme = bs_theme()` call. This is really helpful for playing with branding of your app to match with your organisations branding.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n theme = bs_theme(\n        version = 5, \n        fg = \"rgb(100, 16, 59)\",   # set the foreground colour\n        bg = \"rgb(255, 255, 255)\", # set the background colour \n        primary = \"#7C204F\",       # set the primary colour \n        secondary = \"#F7CBE6\"      # set the secondary colour\n    )\n```\n:::\n\n\n\n\n::: callout-caution\n**Don’t forget** to remove `bs_themer()` from the `server()` once you're done — it's just for development.\n:::\n\nNow we have developed a theme we have another option for how to set the theme arguement for our value boxes. To ensure that when we change the theme of our app our value boxes automatically align with that theme we can set the theme arguement to be `\"primary\"` or \"`secondary\"` and the boxes will inherit the colour values of the themes primary and secondary colours - let's add this now.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlayout_column_wrap(\n      value_box(\n        title = \"Total Cases Reported\",\n        value =  textOutput(\"total_cases_box\"),,\n        showcase = bsicons::bs_icon(\"journal-medical\"),\n        showcase_layout = \"top right\", \n        theme = \"secondary\"\n      ),\n      \n      value_box(\n        title = \"Total Tests Reported\", \n        value = textOutput(\"total_tests_box\"),\n        showcase = bsicons::bs_icon(\"calendar\"), \n        showcase_layout = \"top right\", \n        theme = \"secondary\" \n      ), \n      # value_box(title = \"Value box 3\", value = 123), \n      # value_box(title = \"Value box 4\", value = 456), \n      # value_box(title = \"Value box 5\", value = 789), \n      # value_box(title = \"Value box 6\", value = 101112)\n    )\n```\n:::\n\n\n\n\n![](images/value-box-theme-primary.PNG)\n\n### Exercise 10\n\n10. Now you have the value boxes set to inherit theme colours test out some more themes are render your app to see how these automatically change. **Hint:** try setting each value box theme to a different value.\n\n## Adding a Logo to Your App\n\nOnce you’ve customized the colors and fonts, finish off your look by **adding a logo** (or icon/banner) to the top of your `sidebar = sidebar()` code.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# <<< NEW Adding Logo >>>\nsidebar = sidebar(\n      tags$img(src = \"AMMnet-logo.png\"), # make sure this image exists in a folder called www\n      p(\"Dashboard for examining province level malaria indicators in Laos.\n         Select a province and data series to view the trends over time.\"),\n      \n      # remaining code \n      ... \n) \n```\n:::\n\n\n\n\n![](images/logo-inclusion.PNG)\n\n📂 Folder Setup\n\n-   Create a `www/` folder in your app directory if it doesn’t exist.\n\n-   Save your logo or image as `logo.png` (or any name).\n\n-   Shiny will automatically read image files from that folder.\n\n### Exercise 11\n\n11. Find a logo online (e.g., your org, a flag, or malaria-related symbol or an image of your pet). Create and save it to your app’s `www/` folder. Add it to the sidebar using `tags$img()`.\n\n## Wrapping up Part 3 — Building for the User\n\nIn Part 3, we made your app feel more professional and intuitive for end users:\n\n-   Added **validation messages** to guide users when inputs are missing.\n\n-   Included **descriptive text** in your sidebar and main title.\n\n-   Applied a **customizable visual theme** with `{bslib}`.\n\n-   Enhanced **branding** by adding a logo.\n\n    Made sure your **value boxes inherit theme colors** automatically.\n\nThese are small details — but they make your app feel polished, intentional, and ready to share with end users.\n\n## Part 4: Addiditional Outputs\n\nNow that we’ve built a simple reactive and styled our app, let’s level up by introducing **addiditional output types** - we can convey more information than what we have currentlly presented in our app by adding more outputs.\n\nA reminder that Shiny supports a wide range of different output types\n\n![](images/shiny-output-types.PNG)\n\nWe'll walk through some different examples of outputs and building them from our current dataset.\n\n## Computed Variables and conditional widgets\n\nOne of the powerful benefits of building dashboards in R is that we can compute new indicators directly inside our Shiny app using the data already loaded.\n\nLet’s take **Test Positivity Rate (TPR)** as an example. This isn’t directly stored in our dataset but can easily be computed:\n\n> **TPR = Confirmed Cases / Malaria Tests**\n\nWe will create this as a computed reactive output, and allow the user to **toggle** whether they want to view this indicator.\n\nThis approach is helpful in malaria dashboards where:\n\n-   Some indicators are derived\n\n-   Users may want optional, on-demand metrics\n\n-   You want to avoid recalculating unnecessary metrics until they are requested\n\nLet’s start by giving the user a checkbox to control whether to calculate and display TPR:\n\nBelow our current data series selection add:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add TPR checkbox\ncheckboxInput(\n        inputId = \"include_tpr\", # name ID\n        label = \"Calculate and diaplay Test Positivity Rate (TPR)\", # User side title\n        value = FALSE # set to be unclicked as default\n      )\n```\n:::\n\n\n\n\nHowever — we only want this checkbox to be available when both `malaria_cases` and `malaria_tests` data are selected for plotting. Otherwise, calculating TPR doesn’t make sense.\n\nShiny allows us to dynamically render UI elements using `renderUI()`. We’ll modify our sidebar to only display the TPR toggle when both series are selected. Replace the code in the `ui` with:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# <<< Replace static checkbox with this dynamic output using the uiOutput() call\nuiOutput(\"tpr_checkbox_ui\")\n```\n:::\n\n\n\n\nThen add this logic to your `server()` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Conditional UI for TPR checkbox\noutput$tpr_checkbox_ui <- renderUI({\n  if (all(c(\"malaria_cases\", \"malaria_tests\") %in% input$series_select)) {\n    checkboxInput(\n      inputId = \"include_tpr\",\n      label = \"Calculate and diaplay Test Positivity Rate (TPR)\",\n      value = FALSE\n    )\n  } else {\n    NULL\n  }\n})\n```\n:::\n\n\n\n\nOnce the toggle exists, we can build a reactive plot that only displays if:\n\n-   A province is selected\n\n-   Both indicators are selected\n\n-   The TPR checkbox is enabled\n\nInside the UI element update the empty card with the following logic:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncard(\n  height = 200,\n  full_screen = TRUE, \n  card_header(\"Monthly Malaria Test Positivity\"), \n  card_footer(\"Data source: DHIS2 export\"), \n  card_body(plotlyOutput(\"tpr_plot\"))\n  )\n```\n:::\n\n\n\n\nInside your `server()` function, add:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n # Conditional Plot for TPR \n  output$tpr_plot <- renderPlotly({\n    \n    # Use validate + need to provide informative user messages\n    validate(\n      need(input$include_tpr, \"Enable TPR toggle to display plot.\"),\n      need(input$province_select != \"\", \"Please select a province to view data.\"),\n      need(length(input$series_select) == 2, \"Please select both malaria cases and malaria tests to calculate TPR.\")\n    )\n    \n    # calculate TPR\n    df <- province_data() |>\n      pivot_wider(names_from = var_name, values_from = value) |>\n      arrange(period) |>\n      mutate(\n        tpr = round((malaria_cases / malaria_tests) * 100, 2)\n      )\n    \n    # Plot\n    p <- \n      ggplot(df, aes(x = period, y = tpr)) +\n      geom_point(color = \"#FECC01\") +\n      labs(\n        title = paste(\"Test Positivity Rate (TPR) in:\", input$province_select),\n        x = \"Month\",\n        y = \"TPR (%)\"\n      ) +\n      theme_minimal() +\n      scale_y_continuous(limits = c(0, 100))\n    \n    ggplotly(p)\n  })\n```\n:::\n\n\n\n\n![](images/condiditional-tpr.PNG)\n\nOnce a user safely selects all of the inputs a plot will generate.\n\n![](images/including-tpr.PNG)\n\n-   `validate()` + `need()` provide friendly user-facing error messages inside the plot container.\n\n-   Only once all conditions are met, the plot is rendered.\n\n-   This is much more user-friendly than simply leaving the plot blank or throwing errors!\n\n### Exrecise 12\n\nNow let’s reinforce your learning with a short coding challenge:\n\n12. Create a new **value box** that displays the *average TPR for the year*, but only when the checkbox `include_tpr` is turned on.\n\n**Your logic should:**\n\n-   Calculate the TPR inside the server (same as you did for the plot) but use `sumarise(tpr = mean(tpr, na.rm = TRUE)` to take the average value.\n-   Conditionally display the value box only when the checkbox `include_tpr` is TRUE\n-   Keep using `province_data()` for your data filtering\n-   You can use `renderUI()` to conditionally create the value box.\n-   You'll still need a separate server-side calculation to compute the average TPR.\n\n::: {.callout-tip collapse=\"true\" title=\"Show Solution\"}\nCompute average TPR: Add this to your `server()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput$tpr_value <- renderText({\n  req(input$include_tpr) # requires the TPR check to be TRUE \n  \n  # data processing\n  df <- \n    province_data() |> # filters to province\n    pivot_wider(names_from = var_name, values_from = value) |> #widens data frame to have a column per indicator\n    summarise(tpr = mean((malaria_cases / malaria_tests) * 100, na.rm=TRUE)) # takes average of TPR on % scale \n  \n  avg_tpr <- round(df$tpr, 1) # rounds to one decimal place\n  \n  avg_tpr # returns value \n})\n```\n:::\n\n\n\n\nCondiditionally display the value box\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput$tpr_value_box <- renderUI({\n  if (isTRUE(input$include_tpr))  { # requires TPR check to be active\n    \n    # standard value box set up \n    value_box(\n      title = \"Average TPR (%)\",\n      value = textOutput(\"tpr_value\"), # using condiditional value \n      showcase = bsicons::bs_icon(\"percent\"),\n      showcase_layout = \"top right\",\n      theme = \"secondary\"\n    )\n  } else {\n    NULL # if not checked then nothing is displayed\n  }\n})\n```\n:::\n\n\n\n\nUpdate our UI code\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    layout_column_wrap(\n      value_box(\n        title = \"Total Cases Reported\",\n        value =  textOutput(\"total_cases_box\"),,\n        showcase = bsicons::bs_icon(\"journal-medical\"),\n        showcase_layout = \"top right\", \n        theme = \"secondary\"\n      ),\n      \n      value_box(\n        title = \"Total Tests Reported\", \n        value = textOutput(\"total_tests_box\"),\n        showcase = bsicons::bs_icon(\"calendar\"), \n        showcase_layout = \"top right\", \n        theme = \"secondary\" \n      ), \n      uiOutput(\"tpr_value_box\") # uiOutput linked to uiRender for the value boz\n    )\n```\n:::\n\n\n\n\n![](images/conditional-value-box.PNG)\n:::\n\nYou may notice here that our app has a blank space where the Test Positivity values are expected to be which doesn't look very professional.\n\nTo prevent the empty placeholder space when the toggle is off, we need to dynamically generate the entire set of value boxes using `renderUI()`.\n\nInstead of placing `uiOutput(\"tpr_value_box\")` inside your existing `layout_column_wrap()`, we will let the server fully control which value boxes appear at any moment.\n\nWe first calculate the TPR summary as before, but keep the calculation separate from the UI logic.\n\nAdd this to your `server()` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute average TPR when toggle is active as before\noutput$tpr_value <- renderText({\n  req(input$include_tpr)\n  \n  df <- province_data() |>\n    pivot_wider(names_from = var_name, values_from = value) |>\n    summarise(tpr = mean((malaria_cases / malaria_tests) * 100, na.rm=TRUE))\n  \n  avg_tpr <- round(df$tpr, 1)\n  avg_tpr\n})\n```\n:::\n\n\n\n\nNow we wrap all value boxes together inside one `renderUI()` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Dynamically render full value box row based on toggle\noutput$value_boxes <- renderUI({\n  \n  # Always include these two\n  boxes <- list(\n    value_box(\n      title = \"Total Cases Reported\",\n      value = textOutput(\"total_cases_box\"),\n      showcase = bsicons::bs_icon(\"journal-medical\"),\n      showcase_layout = \"top right\", \n      theme = \"secondary\"\n    ),\n    value_box(\n      title = \"Total Tests Reported\", \n      value = textOutput(\"total_tests_box\"),\n      showcase = bsicons::bs_icon(\"calendar\"), \n      showcase_layout = \"top right\", \n      theme = \"secondary\" \n    )\n  )\n  \n  # Conditionally add TPR box only if checkbox is ON\n  if (isTRUE(input$include_tpr)) {\n    boxes <- append(boxes, list(\n      value_box(\n        title = \"Average TPR (%)\",\n        value = textOutput(\"tpr_value\"),\n        showcase = bsicons::bs_icon(\"percent\"),\n        showcase_layout = \"top right\",\n        theme = \"secondary\"\n      )\n    ))\n  }\n  \n  # Wrap all boxes inside layout_column_wrap\n  layout_column_wrap(!!!boxes)\n})\n```\n:::\n\n\n\n\n> The `!!!` operator (from `rlang`) safely unpacks the list into multiple arguments for `layout_column_wrap()`. This allows us to dynamically build the list of value boxes.\n\nInside your existing `ui`, replace your previous hard-coded `layout_column_wrap()` entirely with:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuiOutput(\"value_boxes\")\n```\n:::\n\n\n\n\nNow your app will only show the TPR value box when appropriate — without leaving any empty space when the toggle is off! Key TakeAways:\n\n-   `renderUI()` gives you full control over when and how UI elements appear.\n\n-   You avoid “empty shells” by only adding UI objects when their underlying data exists.\n\n-   The user experience is cleaner, avoids confusion, and reflects the actual available information.\n\n## Extension\n\nHaving the data series selection buttons in the sidebar when they control all of the plots on the dashbaord is okay but if we want to add addiditional plots a long list of selection boxes may be confusing for the user.\n\nWhat we can do is build a card with a sidebar for selections within that card.\n\nFor the current plots lets create a sidebar within which we select for the case series and TPR checkbox replace our current `layout_column_wrap` with the following:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# insert single card\n card(\n   height = 500, \n   # global card header\n   card_header(\"Malaria Indicator Trends\"),\n   # wihthin a sidebar layout\n   layout_sidebar(\n     sidebar = list(\n       # include original data series checkboes\n       checkboxGroupInput(\n         inputId  = \"series_select\",\n         label    = \"Select data series:\",\n         choices  = c(\n           \"Confirmed Cases\" = \"malaria_cases\",\n           \"Malaria Tests\"   = \"malaria_tests\"\n           )\n         ),\n       # condiditionally render TPR checkbox\n       uiOutput(\"tpr_checkbox_ui\")\n       ),\n     # add the card body for plots \n     card_body(\n       # wrap the calls into a column layout\n       layout_column_wrap(\n         plotlyOutput(\"ts_plot\"),\n         plotlyOutput(\"tpr_plot\")\n         )\n       ),\n     card_footer(\"Data source: DHIS2 export\")\n     )\n    )\n```\n:::\n\n\n\n\n![](images/sidebar-inside-plot-card.PNG)\n\nThis functionality would be nicer if first plot could take up the full width of the card when the TPR box is not checked - we can acheive this by making the following changes:\n\nInstead of hard-coding the layout inside `card_body()` we can replace it with a dynamic UI placeholder:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncard(\n  full_screen = TRUE,\n  card_header(\"Malaria Indicator Trends\"),\n  layout_sidebar(\n    sidebar = list(\n      checkboxGroupInput(\n        inputId  = \"series_select\",\n        label    = \"Select data series:\",\n        choices  = c(\n          \"Confirmed Cases\" = \"malaria_cases\",\n          \"Malaria Tests\"   = \"malaria_tests\"\n        )\n      ),\n      uiOutput(\"tpr_checkbox_ui\")\n    ),\n    card_body(\n      # UI output that will dynamically render different layout\n      uiOutput(\"ts_plots_ui\")\n    ),\n    card_footer(\"Data source: DHIS2 export\")\n  )\n)\n```\n:::\n\n\n\n\nAnd then we can update the server code to conditionally render the plots based on whether the TPR checkbox is selected or not:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput$ts_plots_ui <- renderUI({\n  \n  # Check whether TPR checkbox is selected\n  show_tpr <- input$include_tpr  # adjust to your actual checkbox input ID\n\n  if (isTRUE(show_tpr)) {\n    # Show both plots side by side\n    layout_column_wrap(\n      col_widths = c(6, 6),  # 50-50 width\n      plotlyOutput(\"ts_plot\"),\n      plotlyOutput(\"tpr_plot\")\n    )\n  } else {\n    # Show single plot full width\n    layout_column_wrap(\n      col_widths = c(12),  # full width\n      plotlyOutput(\"ts_plot\")\n    )\n  }\n})\n```\n:::\n\n\n\n\n![](images/taking-up-full-card.PNG)\n\n![](images/sharing-the-space.PNG)\n\n### Stretch Exercise\n\n🎯 Your Task - add a new card panel below the current plots showing a time series plot of incidence per 1,000 people in the selected province.\n\nThis plot will:\n\n-   Use data where `var_name == \"malaria_cases_per_1000\"`\n\n-   Show a single line plot with one point per month\n\n-   Appear in a new `card()` component with a header and footer\n\n-   Only display when a province `input$province_select` is selected, prior to showing a plot display a helpful message to let users know to select a province\n\n-   Use `renderPlotly()` to make it interactive\n\n::: {.callout-tip collapse=\"true\" title=\"Show Solution\"}\nAdd a new card to the UI\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Incidence plot card \n    card(\n      height = 400,\n      card_header(\"Malaria Incidence Trends\"),\n      card_body(plotlyOutput(\"inc_plot\")),\n      card_footer(\"Data source: DHIS2 export\")\n    )\n```\n:::\n\n\n\n\nAdd plot code to the server\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Incidence plot \n  output$inc_plot <- renderPlotly({\n    # Add placeholders for input validation\n    validate(\n      need(input$province_select != \"\", \"Please select a province to view data.\")\n    )\n    \n    # filter dataset\n    df <- province_data() |>\n      filter(var_name == \"malaria_cases_per_1000\") \n    \n    # Ensure there is data to plot\n    validate(\n      need(nrow(df) > 0, \"No incidence data available for this province.\")\n    )\n    \n    # Plot\n    p <- \n      ggplot(df, aes(x = period, y = value)) +\n      geom_line(color = \"#FECC01\") +\n      geom_point(color = \"#FECC01\") +\n      labs(\n        title = paste(\"Malaria Incidence in:\", input$province_select),\n        x = \"Month\",\n        y = \"Incidence (per 1,000)\"\n      ) +\n      theme_minimal()\n    \n    ggplotly(p)\n  })\n```\n:::\n\n\n\n\n![](images/including-incidence.PNG)\n:::\n\n## Including Leaflet Maps\n\nNow that your dashboard includes time series and summary statistics, let’s add a **spatial view** using an interactive map. This will help users visually explore **malaria burden across provinces**.\n\nWe’ll use the `{leaflet}` package to create a **map** of average annual incidence per 1,000 people, and we’ll highlight the **selected province** from the sidebar dropdown.\n\nThink of leaflet as allowing us to use a google maps style map to our dashboard rather than a static image.\n\nAn interactive **leaflet map** that:\n\n-   Fills each province with a color based on **average annual incidence**\n\n-   Adds a **legend** for the color scale\n\n-   **Highlights the selected province** with a bold black outline\n\n-   Shows **tooltips** when hovering over provinces\n\nFor plotting maps we need to ensure we have a shapefile at the correct administrative boundary - we have one saved in the `>\"data-outputs\"` folder on the GitHub so make sure it exists in your local files too by downloading.\n\nAt the top of your app (after loading your libraries and data), add:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadm1_shp <- st_read(\"./data-outputs/adm1_shapefile.shp\")\n```\n:::\n\n\n\n\nAdd a new column layout to ensure the map and the incidence plot fall on the same row of the dashboard:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlayout_columns(\n      card(\n        height = 400,\n        card_header(\"Malaria Incidence Trends\"),\n        card_body(plotlyOutput(\"inc_plot\", height = \"350px\")),\n        card_footer(\"Data source: DHIS2 export\")\n      ), \n      card(\n        height = 400,\n        card_header(\"Average Annual Incidence Map\"),\n        card_body(leafletOutput(\"inc_map\", height = \"350px\")),\n        card_footer(\"Data source: HumData for shape files, DHIS2 for malaria data\")\n      )\n    )\n```\n:::\n\n\n\n\nNow buid the Maps using Leaflet Syntax in the server. We add a highlight outline to the Province that the user has selected.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n output$inc_map <- renderLeaflet({\n    \n    # Add placeholders for input validation\n    validate(\n      need(input$province_select != \"\", \"Please select a province to view data.\")\n    )\n    \n    # Summarise incidence by province\n    df <- app_data |>\n      filter(var_name == \"malaria_cases_per_1000\") |>\n      group_by(organisation_unit) |>\n      summarise(inc = mean(value, na.rm = TRUE))\n    \n    # Join data to spatial file\n    df_shape <- left_join(adm1_shp, df, by = c(\"org_unit\" = \"organisation_unit\"))\n    \n    # Create color palette\n    pal <- colorNumeric(\n      palette = \"YlOrRd\",\n      domain = df_shape$inc,\n      na.color = \"#f0f0f0\"\n    )\n    \n    leaflet(df_shape) |>\n      addProviderTiles(providers$CartoDB.Positron) |>\n      addPolygons(\n        fillColor = ~pal(inc),\n        weight = ~ifelse(org_unit == input$province_select, 3, 1),\n        color = ~ifelse(org_unit == input$province_select, \"#7C204F\", \"black\"),\n        opacity = 1,\n        fillOpacity = 0.8,\n        label = ~paste0(org_unit, \": \", round(inc, 1), \" per 1,000\"),\n        highlightOptions = highlightOptions(\n          weight = 3,\n          color = \"#333\",\n          fillOpacity = 0.9,\n          bringToFront = TRUE\n        )\n      ) |>\n      addLegend(\n        pal = pal,\n        values = df_shape$inc,\n        title = \"Avg Incidence (per 1,000)\",\n        position = \"bottomright\"\n      )\n  })\n```\n:::\n\n\n\n\n![](images/map.PNG)\n\nIn the current app, your `leaflet()` map uses: `addProviderTiles(providers$CartoDB.Positron)`\n\nThis adds a light, minimal background map. But what if you wanted to give users a different map style?\n\n### Exercise 13\n\n13. Explore other available background tiles using the `leaflet::providers` object. You can see a full list by running this command in your R console: `leaflet::providers` Replace `CartoDB.Positron` with or another of your choice. **Hint:** You only need to replace the argument to `addProviderTiles()`. For example: `addProviderTiles(providers$Esri.WorldImagery)`\n    13. Set the column widths to a new value so that the first incidnece plot takes up more of the row space than the map.\n\n## Adding a Table Output\n\nIn many dashboards, tables complement visualizations by providing users with detailed numeric outputs.\n\nShiny has great support for interactive tables using the **DT** package.\n\nLet’s create a summary table that:\n\n-   Aggregates total cases, total tests, average TPR and average incidence by province and includes the number of months that data is reported for in the province\n\n-   Highlights the currently selected province\n\n-   Displays all provinces at once\n\n-   Is interactive (sortable, searchable, paginated)\n\nWe will use `renderDT()` inside the server and `DTOutput()` inside the UI to create this table.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncard(\n  card_header(\"Summary Table\"),\n  card_body(DTOutput(\"summary_data\")),\n  card_footer(\"Aggregated Annual Values per Province\")\n)\n```\n:::\n\n\n\n\nNow add this code inside your server:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput$summary_data <- renderDT({\n  validate(\n      need(input$province_select != \"\", \"Please select a province to view data.\")\n    )\n    \n  # filter and sumarise data \n  df <- app_data |>\n    filter(var_name %in% c(\"malaria_cases\", \"malaria_tests\", \"malaria_cases_per_1000\")) |>\n    pivot_wider(\n      names_from = var_name,\n      values_from = value,\n    ) |> \n    group_by(organisation_unit) |> \n    mutate(tpr = round((malaria_cases / malaria_tests) * 100, 1)) |> \n    summarise(\n      total_cases = sum(malaria_cases, na.rm = TRUE),\n      total_tests = sum(malaria_tests, na.rm=TRUE), \n      avg_tpr = round(mean(tpr, na.rm=TRUE), 1),\n      avg_inc = round(mean(malaria_cases_per_1000, na.rm=TRUE),1), \n      reporting_months_cases = sum(!is.na(malaria_cases)),\n      reporting_months_tests = sum(!is.na(malaria_tests))\n    ) |> \n    rename(\n      Province = organisation_unit,\n      `Total Cases` = total_cases,\n      `Total Tests` = total_tests,\n      `Average TPR (%)` = avg_tpr,\n      `Avg Incidence` = avg_inc,\n      `Case Reporting Months` = reporting_months_cases,\n      `Test Reporting Months` = reporting_months_tests\n    )\n  \n  # Build DT object\n  dt <- datatable(\n    df,\n    rownames = FALSE, \n    options = list(\n      pageLength = 10,\n      dom = \"tip\",  \n      autoWidth = TRUE\n    )\n  )\n  \n  # Highlight selected province\n  if (input$province_select != \"\") {\n    selected <- input$province_select\n    dt <- dt %>%\n      formatStyle(\n        \"Province\",\n        target = \"row\",\n        fontWeight = styleEqual(selected, \"bold\")\n      )\n  }\n  \n  dt\n})\n```\n:::\n\n\n\n\nWhen you run your app, you now have a sortable, searchable summary table with all provinces. The currently selected province row is bolded too.\n\n![](images/table-out.PNG)\n\n### Exercise 14\n\n14. Users may want to export the summary data to analyze offline, share with colleagues, or integrate into reports. **Your Task:** Add a **Download CSV** button that allows users to download the table displayed above.\n\n**Hints***:*\n\n-   In your **UI**, use `downloadButton()` to add a button.\n\n-   In your **server**, create a `downloadHandler()` that reuses the same code as your `renderDT()` output to generate the CSV file.\n\n-   You can put the button inside the same card as your table, e.g., just above `DTOutput()`.\n\n-   For downloading logic first check out the `downloadHandler` function logic through typing `?downloadHandler` in the Console and check with the example below.\n\n::: {.callout-tip collapse=\"true\" title=\"Show Solution\"}\nAdd the following to your UI\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncard(\n  card_header(\"Summary Table\"),\n  card_body(\n    downloadButton(\"download_summary\", \"Download CSV\"),\n    DTOutput(\"summary_data\")\n  ),\n   card_footer(\"Aggregated Annual Values per Province\")\n)\n```\n:::\n\n\n\n\nAnd the following to the server:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The same data prep code as before but with no DT calls\nsummary_table_data <- reactive({\n  app_data |>\n    filter(var_name %in% c(\"malaria_cases\", \"malaria_tests\", \"malaria_cases_per_1000\")) |>\n    pivot_wider(names_from = var_name, values_from = value) |> \n    group_by(organisation_unit) |> \n    mutate(tpr = round((malaria_cases / malaria_tests) * 100, 2)) |> \n    summarise(\n      total_cases = sum(malaria_cases, na.rm = TRUE),\n      total_tests = sum(malaria_tests, na.rm=TRUE), \n      avg_tpr = round(mean(tpr, na.rm=TRUE), 1),\n      avg_inc = round(mean(malaria_cases_per_1000, na.rm=TRUE),1), \n      reporting_months_cases = sum(!is.na(malaria_cases)),\n      reporting_months_tests = sum(!is.na(malaria_tests))\n    ) |> \n    rename(\n      Province = organisation_unit,\n      `Total Cases` = total_cases,\n      `Total Tests` = total_tests,\n      `Average TPR (%)` = avg_tpr,\n      `Avg Incidence` = avg_inc,\n      `Case Reporting Months` = reporting_months_cases,\n      `Test Reporting Months` = reporting_months_tests\n    )\n})\n\n\n# Enable file download\noutput$download_summary <- downloadHandler(\n  filename = function() { paste0(\"summary_data_\", Sys.Date(), \".csv\") },\n  content = function(file) {\n    write.csv(summary_table_data(), file, row.names = FALSE)\n  }\n)\n```\n:::\n\n\n\n\n![](images/download-handler.PNG)\n:::\n\n-   `DT` package makes fully interactive tables very easy\n\n-   `downloadHandler()` enables full export features\n\n# Wrapping up!\n\nCongratulations 🎉 — by now you’ve successfully built a full working Shiny dashboard that includes:\n\n✅ Reactive filters (province selection & data series toggles)\n\n✅ Computed outputs (test positivity rate calculations)\n\n✅ Multiple output types (value boxes, interactive plots, maps, tables)\n\n✅ Clean layouts using `bslib::page_sidebar(),` `layout_columns(),` and `cards()`\n\n✅ User-friendly UI design (themes, conditional messages, validation prompts)\n\n✅ Downloadable data export\n\n✅ Branding customization (logos, color palettes)\n\nWhere to next...\n\nShiny is an incredibly powerful framework — many production dashboards you see in global health, academia, and industry are built with exactly these same building blocks. Here are a few directions you might want to explore next:\n\n### **Deploying & Sharing Your App**\n\n-   **Local deployment:** You can run apps directly from your computer for local demos.\n\n-   **Cloud deployment:** Share your app with others by publishing on:\n\n```         \n-   [**shinyapps.io**](https://www.shinyapps.io/) (free tier available)\n\n-   **Posit Connect** (for enterprise use $$$)\n\n-   Internal organizational servers (for example, government MoH internal dashboards)\n```\n\n> For this workshop, your app is entirely self-contained. With just the `app.R` file and supporting data files, you can easily deploy to any Shiny hosting platform. It is really important to consider when deploying applications if there are any data sensitivities and perhaps password protection would be recommended.\n\n### Advanced elements\n\nWith these building blocks today you have an excellent springboard to start customising advanced dashboards. When your apps grow significantly in content you might find that your code becomes very long and hard to navigate especially if you're working with a multi-tab dashboard.\n\nIn this instance you could explore multi file applications and reusable functions that are used across multiple elements and can be stored in a `helpers.R` file.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}