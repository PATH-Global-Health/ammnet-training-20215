[
  {
    "objectID": "hand-out.html",
    "href": "hand-out.html",
    "title": "Shiny Dashboard Building Blocks - Reference Summary",
    "section": "",
    "text": "This handout summarizes key Shiny concepts, functions, and patterns you can use when building interactive dashboards.\n\n\nEvery Shiny app has two main components:\n\n\n\n\n\n\n\n\nComponent\nPurpose\nLocation\n\n\n\n\nui\nUser Interface - controls layout and inputs\nTop-level ui &lt;- ...\n\n\nserver\nLogic - computations, data processing, outputs\nInside server &lt;- function(input, output) { ... }\n\n\n\nThe two are linked using shared inputId and outputId values.\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nFunction\nWhen to Use\n\n\n\n\nDropdown\nselectInput()\nFor long lists (e.g., Province selection)\n\n\nCheckboxes\ncheckboxGroupInput()\nFor multiple selections\n\n\nRadio Buttons\nradioButtons()\nFor short lists\n\n\nSingle Checkbox\ncheckboxInput()\nFor TRUE/FALSE toggles\n\n\nSlider\nsliderInput()\nFor numeric ranges\n\n\nDate\ndateInput() / dateRangeInput()\nFor date selection\n\n\n\nEach input requires:\ninputId = \"input_name\", label = \"Display Text\", choices = c(...)\nThe current value is accessed using input$input_name inside the server.\n\n\n\n\n\n\nOutput\nRender Function (Server)\nUI Function\n\n\n\n\nText\nrenderText()\ntextOutput()\n\n\nTable (static)\nrenderTable()\ntableOutput()\n\n\nTable (interactive)\nrenderDT()\nDTOutput()\n\n\nPlot (static)\nrenderPlot()\nplotOutput()\n\n\nPlot (interactive)\nrenderPlotly()\nplotlyOutput()\n\n\nMap\nrenderLeaflet()\nleafletOutput()\n\n\nDynamic UI\nrenderUI()\nuiOutput()\n\n\n\nKey rule: every output has one render*() function (server) and one *Output() function (UI), linked by the same ID.\n\n\n\n\nReactivity allows the app to update automatically when inputs change.\n\nUse reactive({ ... }) to create filtered or computed datasets that update when inputs change.\nUse render*() functions to update outputs.\n\nExample reactive filter:\nprovince_data &lt;- reactive({   req(input$province_select != \"\")\napp_data %&gt;% filter(organisation_unit == input$province_select) })\n\n\n\n\npage_sidebar(): main layout with sidebar + content\nlayout_sidebar(): floating sidebar inside a card\ncard(): container for plots/tables\nvalue_box(): summary KPIs\nlayout_columns(): arrange elements horizontally\nlayout_column_wrap(): responsive wrapping of multiple boxes\n\nExaple layout:\n\nlayout_columns(   \n  value_box(title = \"Cases\", value = textOutput(\"total_cases\")),  \n  value_box(title = \"Tests\", value = textOutput(\"total_tests\")) \n  )\n\n\n\n\n\nUse renderUI() + uiOutput() to dynamically generate inputs or outputs.\nUse validate() and need() to display user prompts when required inputs are missing.\n\n\noutput$tpr_checkbox_ui &lt;- renderUI({\n  if (all(c(\"malaria_cases\", \"malaria_tests\") %in% input$series_select)) {\n    checkboxInput(\"include_tpr\", \"Calculate TPR\", value = FALSE)\n  }\n})\n\n\n\n\n\nUse bslib::bs_theme() to apply consistent color schemes and fonts.\nUse input_dark_mode() to enable light/dark toggle.\nUse Bootstrap icons via bsicons::bs_icon() for value boxes and UI elements.\n\ntheme = bs_theme(version = 5, bootswatch = \"minty\")\n\n\n\nAllow users to download tables using downloadHandler().\nExample:\n\noutput$download_data &lt;- downloadHandler(\n  filename = function() { \"summary.csv\" },\n  content = function(file) { write.csv(summary_data(), file) }\n)\n\n\n\n\n\nShiny Documentation\nMastering Shiny Book\nbslib Theming Guide"
  },
  {
    "objectID": "hand-out.html#shiny-app-structure",
    "href": "hand-out.html#shiny-app-structure",
    "title": "Shiny Dashboard Building Blocks - Reference Summary",
    "section": "",
    "text": "Every Shiny app has two main components:\n\n\n\n\n\n\n\n\nComponent\nPurpose\nLocation\n\n\n\n\nui\nUser Interface - controls layout and inputs\nTop-level ui &lt;- ...\n\n\nserver\nLogic - computations, data processing, outputs\nInside server &lt;- function(input, output) { ... }\n\n\n\nThe two are linked using shared inputId and outputId values."
  },
  {
    "objectID": "hand-out.html#inputs-and-outputs",
    "href": "hand-out.html#inputs-and-outputs",
    "title": "Shiny Dashboard Building Blocks - Reference Summary",
    "section": "",
    "text": "Type\nFunction\nWhen to Use\n\n\n\n\nDropdown\nselectInput()\nFor long lists (e.g., Province selection)\n\n\nCheckboxes\ncheckboxGroupInput()\nFor multiple selections\n\n\nRadio Buttons\nradioButtons()\nFor short lists\n\n\nSingle Checkbox\ncheckboxInput()\nFor TRUE/FALSE toggles\n\n\nSlider\nsliderInput()\nFor numeric ranges\n\n\nDate\ndateInput() / dateRangeInput()\nFor date selection\n\n\n\nEach input requires:\ninputId = \"input_name\", label = \"Display Text\", choices = c(...)\nThe current value is accessed using input$input_name inside the server.\n\n\n\n\n\n\nOutput\nRender Function (Server)\nUI Function\n\n\n\n\nText\nrenderText()\ntextOutput()\n\n\nTable (static)\nrenderTable()\ntableOutput()\n\n\nTable (interactive)\nrenderDT()\nDTOutput()\n\n\nPlot (static)\nrenderPlot()\nplotOutput()\n\n\nPlot (interactive)\nrenderPlotly()\nplotlyOutput()\n\n\nMap\nrenderLeaflet()\nleafletOutput()\n\n\nDynamic UI\nrenderUI()\nuiOutput()\n\n\n\nKey rule: every output has one render*() function (server) and one *Output() function (UI), linked by the same ID."
  },
  {
    "objectID": "hand-out.html#reactivity",
    "href": "hand-out.html#reactivity",
    "title": "Shiny Dashboard Building Blocks - Reference Summary",
    "section": "",
    "text": "Reactivity allows the app to update automatically when inputs change.\n\nUse reactive({ ... }) to create filtered or computed datasets that update when inputs change.\nUse render*() functions to update outputs.\n\nExample reactive filter:\nprovince_data &lt;- reactive({   req(input$province_select != \"\")\napp_data %&gt;% filter(organisation_unit == input$province_select) })"
  },
  {
    "objectID": "hand-out.html#layout-tools",
    "href": "hand-out.html#layout-tools",
    "title": "Shiny Dashboard Building Blocks - Reference Summary",
    "section": "",
    "text": "page_sidebar(): main layout with sidebar + content\nlayout_sidebar(): floating sidebar inside a card\ncard(): container for plots/tables\nvalue_box(): summary KPIs\nlayout_columns(): arrange elements horizontally\nlayout_column_wrap(): responsive wrapping of multiple boxes\n\nExaple layout:\n\nlayout_columns(   \n  value_box(title = \"Cases\", value = textOutput(\"total_cases\")),  \n  value_box(title = \"Tests\", value = textOutput(\"total_tests\")) \n  )"
  },
  {
    "objectID": "hand-out.html#conditional-ui-elements",
    "href": "hand-out.html#conditional-ui-elements",
    "title": "Shiny Dashboard Building Blocks - Reference Summary",
    "section": "",
    "text": "Use renderUI() + uiOutput() to dynamically generate inputs or outputs.\nUse validate() and need() to display user prompts when required inputs are missing.\n\n\noutput$tpr_checkbox_ui &lt;- renderUI({\n  if (all(c(\"malaria_cases\", \"malaria_tests\") %in% input$series_select)) {\n    checkboxInput(\"include_tpr\", \"Calculate TPR\", value = FALSE)\n  }\n})"
  },
  {
    "objectID": "hand-out.html#theming-and-styling",
    "href": "hand-out.html#theming-and-styling",
    "title": "Shiny Dashboard Building Blocks - Reference Summary",
    "section": "",
    "text": "Use bslib::bs_theme() to apply consistent color schemes and fonts.\nUse input_dark_mode() to enable light/dark toggle.\nUse Bootstrap icons via bsicons::bs_icon() for value boxes and UI elements.\n\ntheme = bs_theme(version = 5, bootswatch = \"minty\")"
  },
  {
    "objectID": "hand-out.html#data-export",
    "href": "hand-out.html#data-export",
    "title": "Shiny Dashboard Building Blocks - Reference Summary",
    "section": "",
    "text": "Allow users to download tables using downloadHandler().\nExample:\n\noutput$download_data &lt;- downloadHandler(\n  filename = function() { \"summary.csv\" },\n  content = function(file) { write.csv(summary_data(), file) }\n)"
  },
  {
    "objectID": "hand-out.html#useful-resources",
    "href": "hand-out.html#useful-resources",
    "title": "Shiny Dashboard Building Blocks - Reference Summary",
    "section": "",
    "text": "Shiny Documentation\nMastering Shiny Book\nbslib Theming Guide"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Development of a dynamic dashboard for visualizing malaria epidemiological surveillance data with R-Shiny",
    "section": "",
    "text": "This Website houses the materials for the Ammnet Session - “Development of a dynamic dashboard for visualizing malaria epidemiological surveillance data with R-Shiny”\nDate: Friday 27th June\nLocation: Evasion 3 room\nTime: 9am"
  },
  {
    "objectID": "index.html#part-1",
    "href": "index.html#part-1",
    "title": "Development of a dynamic dashboard for visualizing malaria epidemiological surveillance data with R-Shiny",
    "section": "Part 1",
    "text": "Part 1\n\nLearn how to access DHIS2\nExplore some existing dashboards to see graphical functionality\nLearn how to make a data query to access the data elements, time period and geographical units of interest\nDownload data as a csv\nRead data into R\nClean data, including name cleaning, visual inspection of outliers/missing data, cross-referencing different variables\n\nThe outcome of this session is a cleaned malaria dataset that we’ll use for part 2"
  },
  {
    "objectID": "index.html#part-2",
    "href": "index.html#part-2",
    "title": "Development of a dynamic dashboard for visualizing malaria epidemiological surveillance data with R-Shiny",
    "section": "Part 2",
    "text": "Part 2\n\nUnderstand key elements of Shiny Dashbaords\nGain hands on experience customising Shiny Dashboards\nCreate your own Shiny Dashbaord\n\nThe outcome of this session is a fully interactive local App displaying key malaria program metrics."
  },
  {
    "objectID": "english-slides.html",
    "href": "english-slides.html",
    "title": "Slides in English",
    "section": "",
    "text": "Slides in English\nSlides can be downloaded to your computer or viewed in the browser. Download the slides by clicking the download icon 📥 in the top right corner of the PDF viewer."
  },
  {
    "objectID": "french-slides.html",
    "href": "french-slides.html",
    "title": "Slides en français",
    "section": "",
    "text": "Slides en français\nSlides can be downloaded to your computer or viewed in the browser. Download the slides by clicking the download icon 📥 in the top right corner of the PDF viewer.\nLes diapositives peuvent être téléchargées sur votre ordinateur ou visualisées dans le navigateur. Téléchargez les diapositives en cliquant sur l’icône de téléchargement 📥 dans le coin supérieur droit de la visionneuse PDF."
  },
  {
    "objectID": "dashboarding-slides.html#session-objectives",
    "href": "dashboarding-slides.html#session-objectives",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "🎯 Session Objectives",
    "text": "🎯 Session Objectives\n\nUnderstand key elements of Shiny Dashbaords\n\n\nGain hands on experience customising Shiny dashbaords\n\n\nWe can’t cover all aspects of creating Shiny Dashboards but there are a tonne of great resources online we will share during the course of today!"
  },
  {
    "objectID": "dashboarding-slides.html#what-is-a-dashboard",
    "href": "dashboarding-slides.html#what-is-a-dashboard",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "What is a Dashboard?",
    "text": "What is a Dashboard?\n\nA dashboard is a visual interface for exploring and interacting with data.\nIn public health, dashboards help turn raw data into insights.\nShiny lets you build dashboards directly in R — no web development needed!\n\n\n\n📊 You’ve probably seen dashboards used in the COVID-19 response - what other dashboards can you think of?"
  },
  {
    "objectID": "dashboarding-slides.html#why-use-shiny",
    "href": "dashboarding-slides.html#why-use-shiny",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "Why Use Shiny?",
    "text": "Why Use Shiny?\n✅ Turns R code into interactive web apps\n✅ You don’t need to learn HTML, CSS, or JavaScript\n✅ Great for sharing visualizations, tables, and summaries\n✅ Easy to deploy: share with collaborators or host online\n✅ Allow non R users to interact and explore data without the need to code."
  },
  {
    "objectID": "dashboarding-slides.html#examples-of-dashboards",
    "href": "dashboarding-slides.html#examples-of-dashboards",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "Examples of Dashboards",
    "text": "Examples of Dashboards\nShiny dashbaords can grow to be incredibly complex web applications but can also be small simple tools designed to help colleagues with everyday tasks and problems. Here are two examples of dashboards we’ve created recently at PATH."
  },
  {
    "objectID": "dashboarding-slides.html#anatomy-of-a-shiny-app",
    "href": "dashboarding-slides.html#anatomy-of-a-shiny-app",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "🦵💪 Anatomy of a Shiny App",
    "text": "🦵💪 Anatomy of a Shiny App\nA basic Shiny app has two main parts:\n\nUI (User Interface) – what the user sees and interacts with (frontend)\nServer – what R does behind the scenes - computations and tasks based on the user inputs (backend)\n\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI ----\nui &lt;- fluid_page(\n # Define the layout\n # Define the theme \n # Define user input selection\n # Define types of outputs\n)\n\n# Define server logic ----\nserver &lt;- function(input, output) {\n# Computations \n}\n\n# Run the app ----\nshinyApp(ui = ui, server = server)\nThis code is the bare minimum needed to create a Shiny app. The result is an empty app with a blank user interface."
  },
  {
    "objectID": "dashboarding-slides.html#theming",
    "href": "dashboarding-slides.html#theming",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "🎨 Theming",
    "text": "🎨 Theming\nCustomizing the theme of your dashboard is a really simple way to upgrade the look and feel of your app.\n\n\n\n\nYou can use the {bslib} package to easily:\n\nChange colors, fonts, and spacing\nApply modern Bootstrap themes (like flatly, minty, cosmo)\nPreview changes live while building your app\n\n\n\n\nWe’ll explore this in more detail later — for now, just know it’s easy to give your dashboard a polished, professional look!"
  },
  {
    "objectID": "dashboarding-slides.html#helpful-packages",
    "href": "dashboarding-slides.html#helpful-packages",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "📦 Helpful Packages",
    "text": "📦 Helpful Packages\n\nshiny – the core package\nbslib – for modern dashbaord design\ntidyverse – for data wrangling\nDT – for interactive tables\nplotly – for interactive plots\nleaflet - for open source interactive maps"
  },
  {
    "objectID": "dashboarding-slides.html#helpful-webpages-for-getting-started-with-shiny",
    "href": "dashboarding-slides.html#helpful-webpages-for-getting-started-with-shiny",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "🌐 Helpful Webpages for Getting Started with Shiny",
    "text": "🌐 Helpful Webpages for Getting Started with Shiny\nBelow are some beginner-friendly resources to help you dive deeper into Shiny:\n\n\n\nLink\nDescription\n\n\n\n\nShiny Get Started\nOfficial step-by-step tutorial for beginners, with hands-on examples.\n\n\nShiny Gallery\nExplore live examples of Shiny apps with source code.\n\n\nMastering Shiny (book)\nFree online book by Hadley Wickham covering basics to advanced topics.\n\n\nShiny Cheatsheet\nHandy reference for Shiny functions and UI elements (download the PDF).\n\n\nShiny UI Editor (Experimental)\nDrag-and-drop interface to design your UI visually.\n\n\n\n\n\nThese links are a great place to start exploring after today’s session."
  },
  {
    "objectID": "dashboarding-slides.html#what-youll-build-today-an-r-shiny-dashboard-to-visualize-routine-malaria-data",
    "href": "dashboarding-slides.html#what-youll-build-today-an-r-shiny-dashboard-to-visualize-routine-malaria-data",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "What You’ll Build Today: An R Shiny dashboard to visualize routine malaria data",
    "text": "What You’ll Build Today: An R Shiny dashboard to visualize routine malaria data\n\nPull data from DHIS2 ✔\nClean and summarize key indicators ✔\nBuild simple interactive plots and tables 🔃\nCustomize 🔃"
  },
  {
    "objectID": "dashboarding-slides.html#key-takeaways",
    "href": "dashboarding-slides.html#key-takeaways",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nShiny makes dashboards easy to build in R\nYou’ll learn by doing — today is all about hands-on practice\nYou’ll work with a template and build out each element of the dasboard\nWe’ll go step-by-step 🛠️"
  },
  {
    "objectID": "dashboarding-slides.html#instructions",
    "href": "dashboarding-slides.html#instructions",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "Instructions",
    "text": "Instructions\nFollow the link to the materials worksheet - open in google chrome for auto translate.\nWork through each section and complete the exercises as you go.\nReach out for help or to ask questions!\nEnjoy!!"
  },
  {
    "objectID": "dashboarding-slides.html#example-finished-dashboard",
    "href": "dashboarding-slides.html#example-finished-dashboard",
    "title": "Introduction to R Shiny Dashboarding",
    "section": "Example Finished Dashboard",
    "text": "Example Finished Dashboard"
  },
  {
    "objectID": "dashboard-workshop-materials.html",
    "href": "dashboard-workshop-materials.html",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "",
    "text": "Welcome to the “Developing Data Visualisation Dashboards in R” workshop! In this session, we’ll build a Shiny app step by step, exploring what Shiny can do - from basic reactive plots to interactive tables, maps, and advanced UI elements. Each section includes explanatory text, demo code, and exercises for you to try.\n\nWhy RShiny?\n\nShiny lets you turn R code into interactive web applications without needing to learn HTML/CSS/JS.\nIn malaria programs, routine data (e.g., DHIS2 exports) are key to monitoring. A Shiny dashboard can help stakeholders explore data visually, spot trends, and inform decisions and perform routine analysis.\nWe’ll continue using our DHIS2 dataset that we just downloaded and cleaned.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nBefore you begin:\n\nEnsure you have your R Studio Project open.\nEnsure you have your DHIS2 cleaned data saved into the correct folder: data-outputs/data_dhis2_laos_ammnet_cleaned.csv\nIf you didn’t finish the steps in the earlier session - we have the dataset avaliable for download on the home page.\n\n\n\n\n\nWe need some addiditional packages for this session - install these packages if you don’t have them already using the code below in the console:\n\ninstall.packages(\"shiny\")\ninstall.packages(\"bslib\")\ninstall.packages(\"tidyverse\")\ninstall.packages(\"DT\")\ninstall.packages(\"plotly\")\ninstall.packages(\"leaflet\")\ninstall.packages(\"sf\")\ninstall.packages(\"lubridate\")\ninstall.packages(\"bsicons\")\n\nThese packages will allow us to do the following:\n\nshiny: core package to build apps.\nbslib: theming (Bootstrap customization) and modern dashboard design elements.\ntidyverse: data wrangling (dplyr, ggplot2, readr…).\nDT: interactive tables.\nplotly: interactive plots.\nleaflet & sf: mapping spatial data.\nlubridate: for dealting with date-time.\nbsicons: for using Bootstrap icons in Shiny.\n\n\n\n\nImagine you are a data analyst for the Minstry of Health and you’ve been tasked with creating a way for Provinces in the country to quickly and easily visualise and compare their malaria trends without the need for individual excel files or analyses. That’s the kind of problem we’re framing our dashboard around today. During this session you will:\n\nUnderstand key elements of Shiny Dashbaords\nGain hands on experience customising Shiny dashbaords\n\nWe can’t cover all aspects of creating Shiny Dashboards but there are a tonne of great resources online we will share during the course of today!\nWe’ll start by highlighting some key building blocks of dashbboards before moving into customisations and visualisation rendering.\nIn the end we hope you will have created something like the dashboard as shown below:\n\n\n\n\n\n\n\nTip\n\n\n\nTips for this tutorial\n\nAfter each step of the tutorial ensure you press Run App or Refresh App to visualise your changes\nSometimes cleaning the environment or restartng R can be helpful when if your app isn’t updating with changes.\nTo check the definition, usage and arguements of functions type ? followed by the funcition name in the Console e.g. ?value_box.\nWhen designing a Shiny App - always think about the end user and their journey through the application.\n\n\n\n\n\n\nNow we have Shiny installed we can create our first App. Open up a new R script and save it as app.R in your main project folder.\nCopy the code below which is a demo app the is built into the Shiny package.\n\n#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    https://shiny.posit.co/\n#\n\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n\n    # Application title\n    titlePanel(\"Old Faithful Geyser Data\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"bins\",\n                        \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput(\"distPlot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n\n    output$distPlot &lt;- renderPlot({\n        # generate bins based on input$bins from ui.R\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n        # draw the histogram with the specified number of bins\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\nThis is a simple pre-built demo that generates an app with a slider sliderInput to determine the number of bins on the corresponding histogram plot. You can see with just a few lines of code how easy it is to generate an interactive application!\n\nWhen you run this with Run App in RStudio, Shiny launches a local web app .\nReactivity: When an input changes, reactive code re-executes and updates outputs automatically.\n\nLets close this app and go ahead and build own now!\n\n\n\nBefore jumping into code, a quick reminder of the basic app structure.\nA Shiny app has two key components:\n\nUI (User Interface): defines what users see and interact with: inputs (dropdowns, sliders) and outputs (plots, tables, text). It controls the layout and appearance of your app.\nServer: R code that reacts to user inputs, does computations, and sends rendered outputs to the UI. It contains the instructions that your computer needs to build your app\nFinally the shinyApp function creates Shiny app objects from an explicit UI/server pair.\n\nLets remove the contents of the UI and Server code from the default application to give something like this:\n\n#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    https://shiny.posit.co/\n#\n\nlibrary(shiny)\n\n#-Define UI for application - User Interface------------------------------------\nui &lt;- fluidPage(\n  \n)\n\n#-Define server logic - Computations-------------------------------------------- \nserver &lt;- function(input, output) {\n  \n  # reactive expressions, computations and render functions\n}\n\n#-Run the application-----------------------------------------------------------\nshinyApp(ui = ui, server = server)\n\nNow add in our addiditional library calls that we had installed and will need for this application at the top of the script - Ensure this is written outside of the ui and server functions. This will ensure that these packages are loaded when the app starts up.\n\n#-packages needed---------------------------------------------------------------\nlibrary(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(DT)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(lubridate)\nlibrary(bsicons)\n\n\n\n\nNext we need to ensure we read in the correct data to be able to start creating and generating outputs.\nAdd the following code after the library calls and before the UI code:\n\n#-read in app data once on app start up-----------------------------------------\napp_data &lt;- \n  read.csv(\"./data-outputs/data_dhis2_laos_ammnet_cleaned.csv\") \n\n\n\n     organisation_unit     period               var_name  value\n1 01 Vientiane Capital 2024-01-01          malaria_tests 102.00\n2 01 Vientiane Capital 2024-01-01 malaria_cases_per_1000   1.26\n3 01 Vientiane Capital 2024-01-01          malaria_cases  11.00\n4 01 Vientiane Capital 2024-02-01          malaria_tests 109.00\n5 01 Vientiane Capital 2024-02-01 malaria_cases_per_1000   1.58\n6 01 Vientiane Capital 2024-02-01          malaria_cases  12.00\n\n\nYou might notice that the period colum has been read in as a character variable so we need to ensure that this is in date format.\nAdd the following line of code after you read in the dataset.\n\n# re-classify period as a date \napp_data$period &lt;- lubridate::as_date(app_data$period)\n\nNow we have our data ready to use in the app, we can start building out the UI and Server components."
  },
  {
    "objectID": "dashboard-workshop-materials.html#install-packages",
    "href": "dashboard-workshop-materials.html#install-packages",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "",
    "text": "We need some addiditional packages for this session - install these packages if you don’t have them already using the code below in the console:\n\ninstall.packages(\"shiny\")\ninstall.packages(\"bslib\")\ninstall.packages(\"tidyverse\")\ninstall.packages(\"DT\")\ninstall.packages(\"plotly\")\ninstall.packages(\"leaflet\")\ninstall.packages(\"sf\")\ninstall.packages(\"lubridate\")\ninstall.packages(\"bsicons\")\n\nThese packages will allow us to do the following:\n\nshiny: core package to build apps.\nbslib: theming (Bootstrap customization) and modern dashboard design elements.\ntidyverse: data wrangling (dplyr, ggplot2, readr…).\nDT: interactive tables.\nplotly: interactive plots.\nleaflet & sf: mapping spatial data.\nlubridate: for dealting with date-time.\nbsicons: for using Bootstrap icons in Shiny."
  },
  {
    "objectID": "dashboard-workshop-materials.html#objectives",
    "href": "dashboard-workshop-materials.html#objectives",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "",
    "text": "Imagine you are a data analyst for the Minstry of Health and you’ve been tasked with creating a way for Provinces in the country to quickly and easily visualise and compare their malaria trends without the need for individual excel files or analyses. That’s the kind of problem we’re framing our dashboard around today. During this session you will:\n\nUnderstand key elements of Shiny Dashbaords\nGain hands on experience customising Shiny dashbaords\n\nWe can’t cover all aspects of creating Shiny Dashboards but there are a tonne of great resources online we will share during the course of today!\nWe’ll start by highlighting some key building blocks of dashbboards before moving into customisations and visualisation rendering.\nIn the end we hope you will have created something like the dashboard as shown below:\n\n\n\n\n\n\n\nTip\n\n\n\nTips for this tutorial\n\nAfter each step of the tutorial ensure you press Run App or Refresh App to visualise your changes\nSometimes cleaning the environment or restartng R can be helpful when if your app isn’t updating with changes.\nTo check the definition, usage and arguements of functions type ? followed by the funcition name in the Console e.g. ?value_box.\nWhen designing a Shiny App - always think about the end user and their journey through the application."
  },
  {
    "objectID": "dashboard-workshop-materials.html#set-up-app-skeleton",
    "href": "dashboard-workshop-materials.html#set-up-app-skeleton",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "",
    "text": "Now we have Shiny installed we can create our first App. Open up a new R script and save it as app.R in your main project folder.\nCopy the code below which is a demo app the is built into the Shiny package.\n\n#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    https://shiny.posit.co/\n#\n\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n\n    # Application title\n    titlePanel(\"Old Faithful Geyser Data\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"bins\",\n                        \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput(\"distPlot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n\n    output$distPlot &lt;- renderPlot({\n        # generate bins based on input$bins from ui.R\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n        # draw the histogram with the specified number of bins\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\nThis is a simple pre-built demo that generates an app with a slider sliderInput to determine the number of bins on the corresponding histogram plot. You can see with just a few lines of code how easy it is to generate an interactive application!\n\nWhen you run this with Run App in RStudio, Shiny launches a local web app .\nReactivity: When an input changes, reactive code re-executes and updates outputs automatically.\n\nLets close this app and go ahead and build own now!"
  },
  {
    "objectID": "dashboard-workshop-materials.html#anatomy-of-a-shiny-app",
    "href": "dashboard-workshop-materials.html#anatomy-of-a-shiny-app",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "",
    "text": "Before jumping into code, a quick reminder of the basic app structure.\nA Shiny app has two key components:\n\nUI (User Interface): defines what users see and interact with: inputs (dropdowns, sliders) and outputs (plots, tables, text). It controls the layout and appearance of your app.\nServer: R code that reacts to user inputs, does computations, and sends rendered outputs to the UI. It contains the instructions that your computer needs to build your app\nFinally the shinyApp function creates Shiny app objects from an explicit UI/server pair.\n\nLets remove the contents of the UI and Server code from the default application to give something like this:\n\n#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    https://shiny.posit.co/\n#\n\nlibrary(shiny)\n\n#-Define UI for application - User Interface------------------------------------\nui &lt;- fluidPage(\n  \n)\n\n#-Define server logic - Computations-------------------------------------------- \nserver &lt;- function(input, output) {\n  \n  # reactive expressions, computations and render functions\n}\n\n#-Run the application-----------------------------------------------------------\nshinyApp(ui = ui, server = server)\n\nNow add in our addiditional library calls that we had installed and will need for this application at the top of the script - Ensure this is written outside of the ui and server functions. This will ensure that these packages are loaded when the app starts up.\n\n#-packages needed---------------------------------------------------------------\nlibrary(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(DT)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(lubridate)\nlibrary(bsicons)"
  },
  {
    "objectID": "dashboard-workshop-materials.html#read-in-our-data",
    "href": "dashboard-workshop-materials.html#read-in-our-data",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "",
    "text": "Next we need to ensure we read in the correct data to be able to start creating and generating outputs.\nAdd the following code after the library calls and before the UI code:\n\n#-read in app data once on app start up-----------------------------------------\napp_data &lt;- \n  read.csv(\"./data-outputs/data_dhis2_laos_ammnet_cleaned.csv\") \n\n\n\n     organisation_unit     period               var_name  value\n1 01 Vientiane Capital 2024-01-01          malaria_tests 102.00\n2 01 Vientiane Capital 2024-01-01 malaria_cases_per_1000   1.26\n3 01 Vientiane Capital 2024-01-01          malaria_cases  11.00\n4 01 Vientiane Capital 2024-02-01          malaria_tests 109.00\n5 01 Vientiane Capital 2024-02-01 malaria_cases_per_1000   1.58\n6 01 Vientiane Capital 2024-02-01          malaria_cases  12.00\n\n\nYou might notice that the period colum has been read in as a character variable so we need to ensure that this is in date format.\nAdd the following line of code after you read in the dataset.\n\n# re-classify period as a date \napp_data$period &lt;- lubridate::as_date(app_data$period)\n\nNow we have our data ready to use in the app, we can start building out the UI and Server components."
  },
  {
    "objectID": "dashboard-workshop-materials.html#setting-up-an-empty-layout",
    "href": "dashboard-workshop-materials.html#setting-up-an-empty-layout",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Setting up an Empty Layout",
    "text": "Setting up an Empty Layout\nFor this tutorial we will focus on building our Shiny app using bslib, a modern UI toolkit that gives your app a clean and responsive layout with minimal effort.\nWe’ll begin by setting up a basic dashboard skeleton - no data or inputs yet - just the layout structure using bslib::page_sidebar().\nThis gives us a two-pane layout:\n\nA sidebar (on the left) for inputs or filters\nA main content area (on the right) for plots, tables, or summaries\n\nPaste the following code into your app.R file:\n\n#-Load libraries----------------------------------------------------------------\nlibrary(shiny)\nlibrary(bslib)\nlibrary(tidyverse)\nlibrary(DT)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(lubridate)\n\n#-read in app data once on app start up-----------------------------------------\napp_data &lt;- \n  read.csv(\"./data-outputs/data_dhis2_laos_ammnet_cleaned.csv\") \n\n# re-classify period as a date \napp_data$period &lt;- lubridate::as_date(app_data$period)\n\n#-Define UI for application - User Interface------------------------------------\nui &lt;- page_sidebar(\n  title = \"My Dashboard\",  # Title shown in the top bar\n  \n  sidebar = \"Sidebar\",     # Placeholder sidebar content\n  \n  \"Main content area\"     # Placeholder for main content (e.g., plots or tables)\n  \n)\n\n#-Define server logic - Computations-------------------------------------------- \nserver &lt;- function(input, output) {\n  # Placeholder for reactive expressions and outputs\n}\n\n#-Run the application-----------------------------------------------------------\nshinyApp(ui = ui, server = server)\n\nWhat This Does\n\n\n\n\n\n\n\nComponent\nDescription\n\n\n\n\npage_sidebar()\nCreates a full-page layout with a sidebar + main area\n\n\ntitle = \"...\"\nSets the page title shown in the app’s header bar\n\n\nsidebar = \"...\"\nPlaceholder content for the sidebar (we’ll replace this with inputs soon)\n\n\n\"Main content area\"\nText shown in the main panel (this will later become plots and tables)\n\n\n\nClick Run App in RStudio. You’ll see:\n\nA header bar with the title\nA left-hand sidebar with the word Sidebar\nA main panel with the text Main content area\n\n🎉 That’s your first bslib layout up and running!\n\nYou can add additional elements to the main panel of the page by supplying them to page_sidebar.\nBy default, the sidebar panel will appear on the left side of your app. You can move it to the right side by giving sidebar the optional argument position = \"right\".\n💻 Try this now\nIf you want to, page_sidebar creates a sidebar layout that fills the page, and is a quick way to create a page with a sidebar. If you’d like to create a floating sidebar layout that can appear anywhere on the page, use page_fluid and layout_sidebar.\n\n# Floating sidebar layout\nui &lt;- page_fluid(\n  \n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"), # sidebar elements\n    \n   \"Main contents\" # Main pannel elements\n  )\n)\n\n\nYou’ll notice here that the side bar and main contents panes are much smaller now, this is because page_fluid() allows the contents to scale to the required window size to fit the content.\nShiny also allows for more complex layouts too including options for example, page_navbar creates a multi-page user interface that includes a navigation bar. This layout is great for multistage analysis or reporting.\n\nAnother option for creating multipage dashbaords is through the Tabs\n\nWe will stick to using a single page app today but everything we learn can be applied to controlling multipage apps in the future!"
  },
  {
    "objectID": "dashboard-workshop-materials.html#layout-elements",
    "href": "dashboard-workshop-materials.html#layout-elements",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Layout Elements",
    "text": "Layout Elements\n\nCards()\nNow we have out sidebar and main panel, we can also add containers to the main panel that will house out our data visualisations, cards() are a common organising unit in modern dashboards.\nYou can use the function card() to create a card in your Shiny app. card() creates a regular container with borders and padding.\n\nui &lt;- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\", \n    # including a card container in the main panel\n    card(\n      height=400 # setting the height of the card to ensure we can see it when empty.\n    )\n  )   \n)\n\n\nUse cards to present grouped and related information. Add content to a card by supplying arguments to card().\nCard item functions create various different parts to the card:\n\ncard_header() - A header (with border and background color) for the card(). Typically appears before a card_body().\ncard_footer() - A header (with border and background color) for the card(). Typically appears after a card_body().\ncard_boady() - A general container for the “main content”\n\n\n\nExercise 1\n\nUse the above elements to add a card_header(), card_footer() and card_body() to our current application - Hint: try adding some plain text in ” ” to each of the elements.\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\n\n# inclduing card elements\nui &lt;- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\", \n    card(\n      height=400, #height set to 400 pixels\n      full_screen = TRUE,  #allow card to expand if full screnn button is clicked \n      card_header(\"A Header\"), # add a header\n      card_body(\"Card Body\"),  # add main body \n      card_footer(\"A Footer\")  # add footer\n    )\n  )   \n)\n\n\n\n\n\n\nWe’ll be using cards() alot in this tutorial to house the elements of our dashboard. See the bslib Cards article to learn more about cards.\n\n\n\nvalue_boxes()\nValue boxes are another useful UI component. Use value boxes to highlight important values in your app.\nCreate a value box with the function value_box().\nA value_box() has 4 main parts:\n\nvalue: Some text value.\ntitle: Optional text to display above value.\nshowcase: Optional UI element(s) to display alongside the value.\ntheme: Optional theme to change the appearance of the value box.\n...: Any other text/UI elements to appear below value.\n\n\nui &lt;- page_fluid(\n  \n  #-layout------------------------\n  layout_sidebar(\n    \n    #-sidebar---------\n    sidebar = sidebar(\"Sidebar\"),\n    \n    #-main pannel content----\n    \"Main contents\", \n    \n    # Value Box     \n    value_box(\n      title = \"Value box\", # Title\n      value = 750          # Value to show \n    ),\n    \n    # Card \n    card(\n      height=400, \n      full_screen = TRUE, \n      card_header(\"A Header\"), \n      card_body(\"Card Body\"), \n      card_footer(\"A Footer\")\n    )\n  )   \n)\n\n\nTo make our value boxes stand-out even more we can enhance their appearance through setting their theme colour and including inforgraphic icons.\n\nvalue_box(\n      title = \"Value box\", # Title\n      value = 750,         # Value to show\n      showcase = bsicons::bs_icon(\"laptop\"), #include an icon\n      theme = \"pink\" # change the box theme colour\n    )\n\n\n\n\n\n\n\nNote\n\n\n\nNote: to use Bootstrap icons, use the function bsicons::bs_icon()\nCheck out the library of avaliable icons here\nWe can change the location of value_boxes() using the showcase_layout() arguement - options include \"left center\", \"top-right\". or \"bottom\"\n\n\n\n\nExercise 2\n\nAdd an addiditional value_box() and card() to your current dashboard. Set the card() to a different height and choose a new icon, theme and icon placement for the addiditional value_box()\n\nHint: Bootstrap’s theme colors are drawn from a second color list that includes variations on several main colors, named literally. These colors include \"blue\", \"purple\", \"pink\", \"red\", \"orange\", \"yellow\", \"green\", \"teal\", and \"cyan\".\n\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\n\nui &lt;- page_fluid(\n  \n  #-layout------------------------\n  layout_sidebar(\n    \n    #-sidebar---------\n    sidebar = sidebar(\"Sidebar\"),\n    \n    #-main pannel content----\n    \"Main contents\", \n    \n    # Value Box     \n    value_box(\n      title = \"Value box\", # Title\n      value = 750,         # Value to show\n      showcase = bsicons::bs_icon(\"laptop\"), #include an icon\n      theme = \"pink\" # change the box theme colour\n    ), \n    \n    # second value box \n    value_box(\n      title = \"Value box 2\", \n      value = 1993, \n      showcase = bsicons::bs_icon(\"calendar\"), \n      showcase_layout = \"top right\", \n      theme = \"blue\" \n    ), \n    \n    # Card \n    card(\n      height=400, \n      full_screen = TRUE, \n      card_header(\"A Header\"), \n      card_body(\"Card Body\"), \n      card_footer(\"A Footer\")\n    ), \n    \n    # Second card box \n    card(\n      height = 200, \n      full_screen = TRUE,\n      card_header(\"Another Header\"), \n      card_body(\"Another Card\"), \n      card_footer(\"Another Footer\")\n    )\n  )   \n)"
  },
  {
    "objectID": "dashboard-workshop-materials.html#adjusting-layout-positions",
    "href": "dashboard-workshop-materials.html#adjusting-layout-positions",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Adjusting Layout Positions",
    "text": "Adjusting Layout Positions\nBy default, when you add multiple elements to your main panel, Shiny will place them one after another vertically (i.e., one long column). But as we build real dashboards, we often want to organize elements horizontally or into grids to create a cleaner and more informative user interface.\nThis is where layout functions like layout_columns() and layout_column_wrap() come in.\n\nlayout_columns()\nThe function layout_columns() allows you to place elements next to each other, specifying how many columns wide each element should be. Shiny divides the available space into 12 columns . You can assign any number of columns to each element, as long as they add up to 12 or less.\nLet’s try adding moving our two value boxes side by side:\n\nui &lt;- page_fluid(\n  \n  #-layout------------------------\n  layout_sidebar(\n    \n    #-sidebar---------\n    sidebar = sidebar(\"Sidebar\"),\n    \n    #-main pannel content----\n    \"Main contents\", \n    \n    # Value Boxes in a single row\n    layout_columns(    \n    value_box(\n      title = \"Value box\", # Title\n      value = 750,         # Value to show\n      showcase = bsicons::bs_icon(\"laptop\"), #include an icon\n      theme = \"pink\" # change the box theme colour\n      ), \n    \n    value_box(\n      title = \"Value box 2\", \n      value = 1993, \n      showcase = bsicons::bs_icon(\"calendar\"), \n      showcase_layout = \"top right\", \n      theme = \"blue\" \n      )\n    ), \n    \n    # Card \n    card(\n      height=400, \n      full_screen = TRUE, \n      card_header(\"A Header\"), \n      card_body(\"Card Body\"), \n      card_footer(\"A Footer\")\n    ), \n    \n    # Second card box \n    card(\n      height = 200, \n      full_screen = TRUE,\n      card_header(\"Another Header\"), \n      card_body(\"Another Card\"), \n      card_footer(\"Another Footer\")\n    )\n  )   \n)\n\n\nlayout_columns() automatically places the two value boxes next to each other. By default, each element inside layout_columns() takes up equal space. If you want more control, you can specify col_widths for each element /12 e.g. col_widths``= c(6, 6).\n\n\nExercise 3\n\nUse layout_columns() to set the card() elements into two columns. What do you notice about the height of the cards?\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\n\nui &lt;- page_fluid(\n  \n  #-layout------------------------\n  layout_sidebar(\n    \n    #-sidebar---------\n    sidebar = sidebar(\"Sidebar\"),\n    \n    #-main pannel content----\n    \"Main contents\", \n    \n    # Value Boxes in a single row\n    layout_columns( \n      value_box(\n        title = \"Value box\", # Title\n        value = 750,         # Value to show\n        showcase = bsicons::bs_icon(\"laptop\"), #include an icon\n        theme = \"pink\" # change the box theme colour\n        ), \n      \n      value_box(\n        title = \"Value box 2\", \n        value = 1993, \n        showcase = bsicons::bs_icon(\"calendar\"), \n        showcase_layout = \"top right\", \n        theme = \"blue\" \n        )\n      ), \n    \n    # Cards in a single row\n    layout_columns(\n      card(\n        height=400, \n        full_screen = TRUE, \n        card_header(\"A Header\"), \n        card_body(\"Card Body\"), \n        card_footer(\"A Footer\")\n        ), \n      \n      card(\n        height = 200, \n        full_screen = TRUE,\n        card_header(\"Another Header\"), \n        card_body(\"Another Card\"), \n        card_footer(\"Another Footer\")\n        )\n      ),\n    )   \n  )\n\nThe two cards are now the same height as the tallest card. This is because layout_columns() automatically sets the height of each column to match the tallest element in that row.\n\n\n\n\n\n\nlayout_column_wrap()\nIf you have many elements and want them to automatically wrap onto multiple rows (like a responsive grid), you can use layout_column_wrap().\nFor example, you might want to display six value boxes, but have them wrap automatically depending on screen size:\n\nui &lt;- page_fluid(\n  \n  #-layout------------------------\n  layout_sidebar(\n    \n    #-sidebar---------\n    sidebar = sidebar(\"Sidebar\"),\n    \n    #-main pannel content----\n    \"Main contents\", \n    \n    # Value Boxes in a single row that wraps responsive to screen size\n    layout_column_wrap( \n      value_box(\n        title = \"Value box\", # Title\n        value = 750,         # Value to show\n        showcase = bsicons::bs_icon(\"laptop\"), #include an icon\n        theme = \"pink\" # change the box theme colour\n        ), \n      \n      value_box(\n        title = \"Value box 2\", \n        value = 1993, \n        showcase = bsicons::bs_icon(\"calendar\"), \n        showcase_layout = \"top right\", \n        theme = \"blue\" \n        ), \n      \n      # addiditional boxes\n      value_box(title = \"Value box 3\", value = 123), \n      value_box(title = \"Value box 4\", value = 456), \n      value_box(title = \"Value box 5\", value = 789), \n      value_box(title = \"Value box 6\", value = 101112)\n    ), \n    \n    # Cards in a single row\n    layout_columns(\n      card(\n        height=400, \n        full_screen = TRUE, \n        card_header(\"A Header\"), \n        card_body(\"Card Body\"), \n        card_footer(\"A Footer\")\n        ), \n      \n      card(\n        height = 200, \n        full_screen = TRUE,\n        card_header(\"Another Header\"), \n        card_body(\"Another Card\"), \n        card_footer(\"Another Footer\")\n        )\n      ),\n    )   \n  )\n\n\n\n\n\n\n\n\n\n\n\nThis makes your app much more responsive: as users resize their browser window, the layout adjusts automatically."
  },
  {
    "objectID": "dashboard-workshop-materials.html#widget-control-elements",
    "href": "dashboard-workshop-materials.html#widget-control-elements",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Widget Control Elements",
    "text": "Widget Control Elements\nNow that we’ve set up a clean layout using bslib, let’s add some interactive functionality, the sidebar is where we direct the user to select inputs the will send messages to the Shiny app. Shiny widgets collect a value from your user. When a user changes the widget, the value will change as well.\n\nChoosing the Right Input controls: A Quick Exploration\nBefore we add our first user input, it’s helpful to understand a few common types of control widgets in Shiny and when to use them. Inputs allow users to interact with the webpage by clicking a button, entering text, selecting an option, and more.\nShiny provides several ways for users to make selections here are a couple of options:\n\n\n\n\nInput Type\nFunction\nWhen to Use\n\n\n\n\nDropdown menu\nselectInput()\n✅ Best for long lists — compact and searchable\n\n\nRadio buttons\nradioButtons()\n✅ Best for short lists with a few clear options (e.g., Yes/No, 3-4 choices)\n\n\nCheckbox group\ncheckboxGroupInput()\n✅ Best for selecting multiple options\n\n\nAutocomplete select\nselectizeInput()\n✅ Similar to selectInput(), but includes type-ahead search by default\n\n\nSingle checkbox\ncheckboxInput()\n✅ Best for simple on/off, true/false inputs\n\n\nSlider\nsliderInput()\n✅ Best for selecting continuous values or ranges\n\n\nNumeric input\nnumericInput()\n✅ Best for precise numeric entry\n\n\nText input\ntextAreaInput()\n✅ Best for free text entry (e.g. names, IDs, labels)\n\n\nDate input\ndateInput()\n✅ Best for selecting a single date\n\n\nDate range input\ndateRangeInput()\n✅ Best for selecting a start and end date\n\n\nFile upload\nfileInput()\n✅ Best for allowing users to upload files\n\n\nAction button\nactionButton()\n✅ Best for triggering explicit actions (e.g. submit, run model)\n\n\n\nEach widget function requires several arguments. The first two arguments for each widget are\n\na name for the widget: The user will not see this name, but you can use it to access the widget’s value. The name should be a character string.\na label: This label will appear with the widget in your app. It should be a character string, but it can be an empty string \"\".\n\nIn this example, the name is “action” and the label is “Action”: actionButton(\"action\", label = \"Action\")\nThe remaining arguments vary from widget to widget, depending on what the widget needs to do its job. They include things like initial values, ranges, and increments. You can find the exact arguments needed by a widget on the widget function’s help page, (e.g., ?selectInput).\n\n\nExercise 4\n\nFor our dashboard, we want to be able to select a single province to display our data - lets test out some of these examples above and select the most appropriate option for our dashboard.\n\nReplace your sidebar code with the following:\n\nsidebar = list(\n  p(\"Test different input styles. Which one works best for selecting a province from a long list?\"),\n\n  selectInput(\n    inputId = \"dropdown_test\", # ID name that can pass to the server as input$dropdown_test for processing\n    label = \"Dropdown input (selectInput):\", # Title the user sees on the UI\n    choices = sort(unique(app_data$organisation_unit)) # values to shown in the list drawn from all the unit names in our dataset\n  ),\n\n  radioButtons(\n    inputId = \"radio_test\",\n    label = \"Radio buttons (radioButtons):\",\n    choices = sort(unique(app_data$organisation_unit))\n  ),\n\n  checkboxGroupInput(\n    inputId = \"checkbox_test\",\n    label = \"Checkbox group (checkboxGroupInput):\",\n    choices = sort(unique(app_data$organisation_unit))\n  )\n)\n\n\nReflect:\n\nWhat happens when the list is long?\nWhich is more space-efficient?\nWhat would help users most?\n\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\nFor this app, we’ll use selectInput() because:\n\nWe have many provinces to choose from\nWe only need one selection at a time\nIt’s clean, compact, and familiar"
  },
  {
    "objectID": "dashboard-workshop-materials.html#putting-it-all-together",
    "href": "dashboard-workshop-materials.html#putting-it-all-together",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Putting it all together",
    "text": "Putting it all together\nLets now create the skeleton of our dashboard. Firstly what we want to be able to do is allow user to select a Province.\nWe’ll start by updating the UI to add a control widget that selects for province and in Part 2 we will address adding reactive elements to our output containers.\nLet’s now update the sidebar to add a proper dropdown input for Province selection. Remember to ensure we are reading in our dataset prior to the UI and Server code.\n\n   #-sidebar---------\n    sidebar = sidebar(\n      \n      # Add user input selection \n      p(\"User Inputs\"), # Title\n      \n      selectInput(\n        inputId = \"province_select\",  # ID value\n        label = \"Select a Province:\", # UI side Title\n        choices = c(\"\", sort(unique(app_data$organisation_unit))), # empty first value followed by all of our unique org_unit names\n        selected = \"\" # default value that the application starts with as selected - in our case we want this to be blank. \n        )\n      ),\n\nWhat this is doing:\n\n\n\n\n\n\n\nFunction/Argument\nDescription\n\n\n\n\nselectInput()\nAdds a dropdown input where users can choose a Province\n\n\ninputId = \"province_select\"\nThis ID connects the UI to the server logic (we’ll use it in Part 2)\n\n\nchoices = ...\nPulls all Province names from the dataset and sorts them alphabetically\n\n\nselected = NULL\nNo Province is pre-selected when the app first loads"
  },
  {
    "objectID": "dashboard-workshop-materials.html#pause-reflect-where-we-are",
    "href": "dashboard-workshop-materials.html#pause-reflect-where-we-are",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Pause & Reflect: Where We Are",
    "text": "Pause & Reflect: Where We Are\nBefore we move forward, take a quick moment to review what you’ve built so far:\n✅ You’ve created your own Shiny app from scratch.\n✅ You set up a modern dashboard layout using bslib::page_fluid() and layout_sidebar()\n✅ You’ve learned how to organize content using:\n\ncard() to hold your future plots and tables\nvalue_box() to display key summary indicators\nlayout_columns() and layout_column_wrap() to control the page structure\n\n✅ You’ve explored how to place interactive control widgets into the sidebar using selectInput(), which will allow users to filter the data.\n\nQuick self-check questions\n\nDo you understand the difference between UI and Server parts of the app?\nCan you identify where the user interacts (inputs) vs where outputs will be displayed?\nDo you feel comfortable adding more cards, value boxes, or inputs to your app?"
  },
  {
    "objectID": "dashboard-workshop-materials.html#shiny-output-types",
    "href": "dashboard-workshop-materials.html#shiny-output-types",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Shiny Output Types",
    "text": "Shiny Output Types\nYou can create reactive outputs with a two step process.\n\nAdd an R object to your user interface.\nTell Shiny how to build the object in the server function. The object will be reactive if the code that builds it calls a widget value.\n\nShiny provides a family of functions that turn R objects into output for your user interface. Each function creates a specific type of output.\n\nBelow is a summary of some key output types, the functions to tell shiny what the expect in the UI and the functions to create it in the server and a short desciption of when to use.\n\n\n\n\n\n\n\n\n\nOutput Type\nRender Function (Server)\nDisplay Function (UI)\nWhen to Use\n\n\n\n\nText\nrenderText()\ntextOutput()\nDisplay simple text strings\n\n\nTables (static)\nrenderTable()\ntableOutput()\nShow small static tables\n\n\nTables (interactive)\nrenderDT()\nDT::dataTableOutput()\nShow sortable, searchable tables\n\n\nPlots (static)\nrenderPlot()\nplotOutput()\nStandard static plots (ggplot, base R plots)\n\n\nPlots (interactive)\nrenderPlotly()\nplotlyOutput()\nFully interactive plots (hover, zoom, pan)\n\n\nLeaflet Maps\nrenderLeaflet()\nleafletOutput()\nInteractive geographic maps\n\n\nImages\nrenderImage()\nimageOutput()\nDisplay image files (PNG, JPG, etc.)\n\n\nUI elements (dynamic)\nrenderUI()\nuiOutput()\nDynamically generate any custom UI\n\n\nValue Boxes\n(no render function)\nvalue_box()\nDisplay single KPI summary values\n\n\n\n\nWhat you will notice is that Every output type has:\n\nOne render function → goes in the server\nOne output function → goes in the UI\n\n\nAnd you connect them using a shared outputId"
  },
  {
    "objectID": "dashboard-workshop-materials.html#building-reactive-outputs-ui-and-server-crosstalk",
    "href": "dashboard-workshop-materials.html#building-reactive-outputs-ui-and-server-crosstalk",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Building Reactive Outputs: ui and server crosstalk",
    "text": "Building Reactive Outputs: ui and server crosstalk\nLets work through an example to display the Province that the user selected in the first card of our current dashboard.\nWe want to show some text that says:\n\n“You have selected: [Province]”\n\nTo do this, we add textOutput() to the UI where we want the text to appear,in this instance we add it to the card_body() call to our first card.\n\n    # Cards in a single row\n    layout_columns(\n      card(\n        height=400, \n        full_screen = TRUE, \n        card_header(\"A Header\"), \n        card_body(textOutput(\"selected_province_text\")), # add textOutput to display selected province), \n        card_footer(\"A Footer\")\n        ), \n      \n      card(\n        height = 200, \n        full_screen = TRUE,\n        card_header(\"Another Header\"), \n        card_body(\"Another Card\"), \n        card_footer(\"Another Footer\")\n        )\n      )\n\n\n\n\n\n\n\nNote\n\n\n\nNotice that textOutput takes an argument, the character string \"selected_province_text\". Each of the *Output functions require a single argument: a character string that Shiny will use as the name of your reactive element. Your users will not see this name, but you will use it later.\n\n\nPlacing a function in ui tells Shiny where to display your object. Next, you need to tell Shiny how to build the object.\nWe do this by providing the R code that builds the object in the server function.\nThe server function plays a special role in the Shiny process; it builds a list-like object named output that contains all of the code needed to update the R objects in your app. Each R object needs to have its own entry in the list.\nYou can create an entry by defining a new element for output within the server function, like below. The element name should match the name of the reactive element that you created in the ui.\nIn the server function below, output$selected_province_text matches textOutput(\"selected_province_text \") in your ui.\n\nserver &lt;- function(input, output) {\n  \n  output$selected_province_text &lt;- renderText({\n    # If nothing is selected, show a default message\n    if (input$province_select == \"\") {\n      \"No Province Selected\"\n    } else {\n    # otherwise show the selected value\n      paste(\"You have selected:\", input$province_select)\n    }\n  })\n  \n}\n\ninput is a second list-like object created by the server function. It stores the current values of all of the widgets in your app. These values will be saved under the names that you gave the widgets in your ui.\nSo for example, our app has one widget, one named \"province_select\" .The values of \"province_select\" will be saved in input as input$province_select.\nShiny will automatically make an object reactive if the object uses an input value. For example, the server function above creates a reactive line of text by calling the value of the select box widget to build the text.\n\nWhen the user changes the province name the text outoput will update automatically - try this out.\nWhat you just learned:\n\n\n\nPart\nCode\n\n\n\n\nUI\ntextOutput(\"selected_province_text\")\n\n\nServer\noutput$selected_province_text &lt;- renderText({ ... })\n\n\nLink\nBoth use the same ID: \"selected_province_text\"\n\n\n\nEach entry to output$ &lt;- should contain the output of one of Shiny’s render* functions. These functions capture an R expression and do some light pre-processing on the expression. Use the render* function that corrresponds to the type of reactive object you are making (Pairs are listed in the table above).\nEach render* function takes a single argument: an R expression surrounded by braces, {}. The expression can be one simple line of text, or it can involve many lines of code, as if it were a complicated function call.\nThink of this R expression as a set of instructions that you give Shiny to store for later. Shiny will run the instructions when you first launch your app, and then Shiny will re-run the instructions every time it needs to update your object.\nFor this to work, your expression should return the object you have in mind (a piece of text, a plot, a data frame, etc.). You will get an error if the expression returns the wrong type of object."
  },
  {
    "objectID": "dashboard-workshop-materials.html#reactivity-and-data",
    "href": "dashboard-workshop-materials.html#reactivity-and-data",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Reactivity and Data",
    "text": "Reactivity and Data\nIn the previous step our app simply reacts to the user input and displays the Province - now we want to also tell our App to do more with that information by filtering and displaying summary data from our DHIS2 data pull.\nWe want to compute (for now, keep it simple):\n\nTotal number of malaria cases reported in the selected province for the year\n\nWe know our dataset is called app_data, and malaria cases are stored where var_name == \"malaria_cases\".\nInside your server() function, add:\n\nserver &lt;- function(input, output) {\n  \n  # Reactive data filter - filter the app_data when input value is selected\n  province_data &lt;- reactive({\n    req(input$province_select != \"\")  # Only run if province selected\n    \n    app_data %&gt;% \n      filter(organisation_unit == input$province_select) # filter dataset to Province selected\n  })\n  \n  # Compute total cases from filtered data\n  output$total_cases_box &lt;- renderText({\n    df &lt;- province_data() # this act like a function and pulls through our filtered data to an object inside renderText called 'df'\n    \n    total_cases &lt;- df %&gt;%\n      filter(var_name == \"malaria_cases\") %&gt;% # filters to malaria cases data only\n      summarise(total = sum(value, na.rm = TRUE)) %&gt;% # sums values over all periods included\n      pull(total) # pulls out the value from summary calculation into named vector\n    \n    total_cases # final value\n  })\n}\n\nHere we have made our province_data() object reactive - what this means is that every time input$province_select changes, Shiny will automatically re-execute any code that depends on province_data().\nWe use the filtered province_data() in the output$total_cases_box to then create a single value of total cases reported that year.\nWe’re using renderText() as our server side output function - we need to feed this information to our updated value_box() UI code next.\nWe want to replace the value argument with the dynamic text from our server \"total_cases_box\". In your ui, replace the original value box with:\n\n  value_box(\n        title = \"Total Cases Reported\",\n        value =  textOutput(\"total_cases_box\"), # reactive value taken from server side outputs\n        showcase = bsicons::bs_icon(\"journal-medical\"),\n        showcase_layout = \"top right\", \n        theme = \"pink\"\n      )\n\n\nSummary of updates\n\n\n\nReactive filter\nprovince_data &lt;- reactive({ ... })\n\n\nComputation\nsummarise() inside renderText()\n\n\nOutput rendering\noutput$total_cases_box &lt;- renderText({ ... })\n\n\nUI linkage\nvalue = textOutput(\"total_cases_box\")\n\n\n\n\nExercise 5\n\nUpdate the second value box to compute and display total annual tests (var_name == \"malaria_tests\"), update the icon to match the data reporting type, and remove the remaining value boxes for now,\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\n\n# update the value box to contain a renderOutput call\n value_box(\n        title = \"Total Tests Reported\", \n        value = textOutput(\"total_tests_box\"), #render output call\n        showcase = bsicons::bs_icon(\"journal-medical\"), # update icon\n        showcase_layout = \"top right\", \n        theme = \"blue\" \n      )\n\n\n #-Compute total tests from filtered data--------------------------------------------\n  output$total_tests_box &lt;- renderText({\n    \n    df &lt;- province_data() # pull filtered province data\n    \n    total_tests &lt;- df %&gt;%\n      filter(var_name == \"malaria_tests\") %&gt;%\n      summarise(total = sum(value, na.rm = TRUE)) %&gt;% #sum total tesats\n      pull(total)\n    \n    total_tests # return value\n    \n  })\n\n\n\n\n\nGood job! We’ll come back to our value boxes later to add more functionality, but for now let’s focus on adding a time series plot to visualize the reported malaria cases over time."
  },
  {
    "objectID": "dashboard-workshop-materials.html#adding-a-reactive-plot",
    "href": "dashboard-workshop-materials.html#adding-a-reactive-plot",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Adding a Reactive Plot",
    "text": "Adding a Reactive Plot\nNow that we have our value boxes displaying total cases and tests, let’s add a time series plot to visualize malaria cases over time for the selected Province.\nWe’ll use: plotlyOutput() in our UI card to reserve a space for an interactive chart.\nLets update one of our existing cards to include a plotly output.\n\nlayout_columns(\n      card(\n        height=400, \n        full_screen = TRUE, \n        card_header(\"Monthly Malaria Cases\"),    # informative card header\n        card_body(plotlyOutput(\"ts_plot\")),      # include plotlyOutput in the card body and name this output ts_plot\n        card_footer(\"Data source: DHIS2 export\") #informative card footer\n        ), \n      \n      card(\n        height = 200, \n        full_screen = TRUE,\n        card_header(\"Another Header\"), \n        card_body(\"Another Card\"), \n        card_footer(\"Another Footer\")\n        )\n      )\n\nThis creates a card with a header, a plotly output area, and a footer. The plotlyOutput(\"ts_plot\") is where our time series plot will go.\nNow that we’ve created a space for our plot in the UI, it’s time to write the server-side logic that:\n\nCreates a time series plot of malaria cases\nDisplays that plot inside the ts_plot output that we just specified\n\nAdd the following code to the server function:\n\n#-Plot of reported cases over time selected by province---------------------------------\n  output$ts_plot &lt;- renderPlotly({\n      \n    df &lt;- \n      province_data()  %&gt;%  # get province data\n      filter(var_name == \"malaria_cases\") # reduce to cases\n      \n      req(nrow(df) &gt; 0)              # Ensure there are rows to plot\n      \n      # Create a ggplot time series of time on the xaxis cases on the y\n      p &lt;- \n        ggplot(df, aes(x = period, y = value)) +\n        geom_line() +  #add line style\n        geom_point() + # add points to the line\n        labs(\n          title = paste(\"Confirmed Malaria Cases in:\", input$province_select), # add selected province to the title\n          x = \"Month\",\n          y = \"Confirmed Cases\"\n        ) +\n        theme_minimal()\n      \n      # Convert ggplot to interactive Plotly object\n      ggplotly(p)\n      \n    })\n\nWhat this is doing:\n\nrenderPlotly(): Tells Shiny how to render the plotlyOutput() in the UI\nggplot(): creates a time series plot with geom_line() to show the trend of confirmed cases over time.\nggplotly(): converts the ggplot object to a Plotly object for interactivity.\n\n\nTest It\nRun your app and try the following:\n\nSelect a Province from the dropdown\nWatch the plot appear in the card\nHover over points to see values\nTry selecting a different Province, the plot updates automatically!\n\n\n\n\n\n\n\nNote\n\n\n\n📊 Plotly for Interactive Plots\nThe Plotly package allows you to turn static ggplot2 charts into interactive visualizations. This means users can hover over points, zoom in, pan across the plot, and see tooltips with data values.\nIn Shiny, this is especially useful for dashboards where you want dynamic, user-driven exploration of your data.\nWe use the ggplotly() function to convert a regular ggplot object into a Plotly object, making it fully interactive with minimal changes to your code.\nJust remember that not all ggplot2 features translate perfectly, some customization may require testing or tweaking. Or you can always build plots directly using Plotly code but for now we’ll stick with ggplot &gt; ploty conversion.\n\n\n\nExercise 6 -7:\n\n\nModify the plot to include both confirmed cases and malaria tests as two lines (different colors). Hint: check back in your DHIS2 extraction slides for an example plotting multiple indicators. Hint: edit the var_name %in% c()filter to select both indicators. Once rendered plotly has an option to view both hover labels at the same time - see if you can make this work in your local app.\n\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\nFirst update the card header\n\n  card(\n        height=400, \n        full_screen = TRUE, \n        card_header(\"Monthly Malaria Indicators\"),    # Update informative card header\n        card_body(plotlyOutput(\"ts_plot\")),     \n        card_footer(\"Data source: DHIS2 export\") \n        )\n\nAdd the addiditional variable call in the filter and include plot colours - here i’ve selected those in AMMnet Branding.\n\n#-Plot of reported values over time selected by province---------------------------------------\n output$ts_plot &lt;- renderPlotly({\n      \n    df &lt;- \n      province_data()  %&gt;%  # get province data\n      filter(var_name %in%  c(\"malaria_cases\", \"malaria_tests\")) # reduce to cases AND tests\n      \n      req(nrow(df) &gt; 0)              # Ensure there are rows to plot\n      \n      # Create a ggplot time series of time on the xaxis cases on the y, colour by data type\n      p &lt;- \n        ggplot(df, aes(x = period, y = value, col=var_name)) +\n        geom_line() +  #add line style\n        geom_point() + # add points to the line\n        labs(\n          title = paste(\"Malaria Indicators Cases in:\", input$province_select), # add selected province to the title and change name\n          x = \"Month\",\n          y = \"Value\",   # Update\n          col=\"Indicator\" # Update \n        ) +\n        scale_color_manual(values = c(\"malaria_cases\" = \"#571845\", \"malaria_tests\" = \"#C42847\"))+ # set the colour values\n        theme_minimal()\n      \n      # Convert ggplot to interactive Plotly object\n      ggplotly(p)\n      \n    })\n\n\n\n\n\n\nAdd a new input selection that lists the two data elements (“confirmed cases”, “malaria tests”) so users can toggle which series appear. Hint use: checkboxGroupInput() to allow multiple selections to be toggeled on and off. Hint think carefully about how to use the new input$ value to filter the dataset.\n\n\n\n\n\n\n\n\n💡 Show Solution\n\n\n\n\n\n\n    #-sidebar---------\n    sidebar = sidebar(\n      \n      # Add user input selection \n      p(\"User Inputs\"), # Title\n      \n      # Province selection \n      selectInput(\n        inputId = \"province_select\",  # ID value\n        label = \"Select a Province:\", # UI side Title\n        choices = c(\"\", sort(unique(app_data$organisation_unit))), # empty first value followed by all of our unique org_unit names\n        selected = \"\" # default value that the application starts with as selected - in our case we want this to be blank. \n        ), \n      \n      # Data series toggle \n      checkboxGroupInput(\n        inputId = \"series_select\", # give usable ID\n        label = \"Select data series:\", # UI side title\n        choices = c(\"Confirmed Cases\" = \"malaria_cases\", # filter variables with nice formatting for the UI\n                    \"Malaria Tests\"  = \"malaria_tests\"),\n        selected = NULL #ensure selection is empty initially\n      )\n      )\n\n\n#-Plot of reported values over time selected by province---------------------------------------\noutput$ts_plot &lt;- renderPlotly({\n      \n    df &lt;- \n      province_data()  %&gt;%  # get province data\n      filter(var_name %in% input$series_select) # Get the filtered data as per input \n      \n      req(nrow(df) &gt; 0)              # Ensure there are rows to plot\n      \n      # Create a ggplot time series of time on the xaxis cases on the y, colour by data type\n      p &lt;- \n        ggplot(df, aes(x = period, y = value, col=var_name)) +\n        geom_line() +  #add line style\n        geom_point() + # add points to the line\n        labs(\n          title = paste(\"Malaria Indicators Cases in:\", input$province_select), # add selected province to the title and change name\n          x = \"Month\",\n          y = \"Confirmed Cases\", \n          col=\"Indicator\"\n        ) +\n        scale_color_manual(values = c(\"malaria_cases\" = \"#571845\", \"malaria_tests\" = \"#C42847\"))+ # set the colour values\n        theme_minimal()\n      \n      # Convert ggplot to interactive Plotly object\n      ggplotly(p)\n      \n    })"
  },
  {
    "objectID": "dashboard-workshop-materials.html#end-of-part-2-what-youve-built-so-far",
    "href": "dashboard-workshop-materials.html#end-of-part-2-what-youve-built-so-far",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "End of Part 2 — What You’ve Built So Far",
    "text": "End of Part 2 — What You’ve Built So Far\n✅ You now have a fully reactive dashboard skeleton:\n\nInputs: User selects a Province and which data series to view.\nReactive filtering: The app filters the dataset automatically.\nOutputs:\n\nValue boxes update in real-time\nInteractive time series plots update dynamically\nYou’ve seen how both text-based and graphical outputs follow the same reactivity pattern."
  },
  {
    "objectID": "dashboard-workshop-materials.html#adding-messages-and-prompts",
    "href": "dashboard-workshop-materials.html#adding-messages-and-prompts",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Adding messages and prompts 📧",
    "text": "Adding messages and prompts 📧\nWhen we first launch the app, the dashboard appears blank until a user selects a Province and at least one data series. While this is expected, it might not be intuitive for users who are unfamiliar with how the app works.\nTo improve the user experience, we can add helpful messages that appear when required inputs are missing. This kind of feedback, often referred to as conditional UI messaging, helps guide users through the app and ensures they understand what to do next.\nWe’ll use the validate() and need() functions from Shiny to conditionally display informative prompts in place of a plot until the required input is provided.\nTo do this we can add the following code to the top of all of our server code for value boxes add:\n\n# condiditional messaging -  Check if province selection is made and if not display the following message \nvalidate(\n  need(input$province_select != \"\", \"Select a province\")\n  )\n\nTo the plot server code add the following:\n\n# condiditional messaging -  Check if province selection is made and if not display the following message \n# Check if data selected and prompt to select data series\nvalidate(\n  need(input$province_select != \"\", \"Please select a province to view data.\"),\n  need(length(input$series_select) &gt; 0, \"Please select at least one data elemtent to generate the plot.\")\n  )\n\nWhat This Does:\n\nvalidate() Tells Shiny to check conditions before rendering output\nneed() Provides a custom message that is shown in the output space when a condition isn’t met.\nThese messages appear in the same area where the plot would go, giving users immediate, contextual guidance."
  },
  {
    "objectID": "dashboard-workshop-materials.html#adding-a-short-description-of-the-application",
    "href": "dashboard-workshop-materials.html#adding-a-short-description-of-the-application",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Adding a Short Description of the Application 🖊️",
    "text": "Adding a Short Description of the Application 🖊️\nAs we continue to improve the user experience, it’s helpful to provide some context or instructions directly in the app. One simple but effective enhancement is adding a short descriptive text at the top of the sidebar panel and a Title to the main plot output.\nThis gives users a quick overview of what the tool does, what the inputs mean, or what they should expect to see - without needing to refer to an external guide.\n\nExercise 8\n\nIn your ui replace the p(\"User Inputs\") with a more informative description. And add a main title to replace \"Main contents\" . Hint use the function h1(\" \") to add your title as this will give it a Header level 1 style.\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\n\n    #-sidebar---------\n    sidebar = sidebar(\n      \n      # informative title\n      p(\"Dashboard for examining province level malaria indicators in Laos.\n         Select a province and data series to view the trends over time.\"),\n      \n      # Province selection \n      selectInput(\n        inputId = \"province_select\",  # ID value\n        label = \"Select a Province:\", # UI side Title\n        choices = c(\"\", sort(unique(app_data$organisation_unit))), # empty first value followed by all of our unique org_unit names\n        selected = \"\" # default value that the application starts with as selected - in our case we want this to be blank. \n        ), \n      \n      # Data series toggle \n      checkboxGroupInput(\n        inputId = \"series_select\", # give usable ID\n        label = \"Select data series:\", # UI side title\n        choices = c(\"Confirmed Cases\" = \"malaria_cases\", # filter variables with nice formatting for the UI\n                    \"Malaria Tests\"  = \"malaria_tests\"),\n        selected = NULL #ensure selection is empty initially\n      )\n      ),\n    \n    #-main pannel content----\n    h1(\"Malaria Indicators Dashboard\"), # Main title of the app\n\nWhat This Does:\n\nThe p() function inserts a paragraph of plain text at the top of the sidebar.\nThis lightweight description gives users quick context about what they’re seeing and how to interact with the app.\n\n\n\n\n\n\nKeep this description short and scannable. If you want to include more detailed information (e.g., methodology or indicator definitions), we could use a collapsible help text, a modal popup, or a separate “About” tab - we’ll suggest some resources for this later in the tutorial."
  },
  {
    "objectID": "dashboard-workshop-materials.html#theming-with-bs_theme",
    "href": "dashboard-workshop-materials.html#theming-with-bs_theme",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Theming with bs_theme 🎨",
    "text": "Theming with bs_theme 🎨\nUntil now, our dashboard has been using the default Shiny style: functional,but plain and we added colour values to our value_box. We can now take advantage of the bslib package to apply modern, responsive theming with just a few lines of code (via bootswatch).\nApplying a theme makes your app easier to use, improves readability, and gives it a more professional look - especially useful when sharing with stakeholders or integrating into your organization’s brand.\nWe can tell our app directly to use a built-in theme in the UI code:\n\n#-Define UI for application - User Interface------------------------------------\nui &lt;- page_fluid(\n  \n  #-layout------------------------\n  layout_sidebar(\n    \n    #-sidebar---------\n    sidebar = sidebar(\n      \n      # informative title\n      p(\"Dashboard for examining province level malaria indicators in Laos.\n         Select a province and data series to view the trends over time.\"),\n      \n      # Province selection \n      selectInput(\n        inputId = \"province_select\",  # ID value\n        label = \"Select a Province:\", # UI side Title\n        choices = c(\"\", sort(unique(app_data$organisation_unit))), # empty first value followed by all of our unique org_unit names\n        selected = \"\" # default value that the application starts with as selected - in our case we want this to be blank. \n        ), \n      \n      # Data series toggle \n      checkboxGroupInput(\n        inputId = \"series_select\", # give usable ID\n        label = \"Select data series:\", # UI side title\n        choices = c(\"Confirmed Cases\" = \"malaria_cases\", # filter variables with nice formatting for the UI\n                    \"Malaria Tests\"  = \"malaria_tests\"),\n        selected = NULL #ensure selection is empty initially\n      )\n      ),\n    \n    #-main pannel content----\n    h1(\"Malaria Indicators Dashboard\"), # Main title of the app\n    \n    # Value Boxes in a single row that wraps responsive to screen size\n    layout_column_wrap( \n      value_box(\n        title = \"Total Cases Reported\",\n        value =  textOutput(\"total_cases_box\"), # reactive value taken from server side outputs\n        showcase = bsicons::bs_icon(\"journal-medical\"),\n        showcase_layout = \"top right\", \n        theme = \"pink\"\n      ), \n      \n      value_box(\n        title = \"Total Tests Reported\", \n        value = textOutput(\"total_tests_box\"), #render output call\n        showcase = bsicons::bs_icon(\"journal-medical\"), # update icon\n        showcase_layout = \"top right\", \n        theme = \"blue\" \n      )\n      \n      # addiditional boxes\n      # value_box(title = \"Value box 3\", value = 123), \n      # value_box(title = \"Value box 4\", value = 456), \n      # value_box(title = \"Value box 5\", value = 789), \n      # value_box(title = \"Value box 6\", value = 101112)\n      ), \n    \n    # Cards in a single row\n    layout_columns(\n      card(\n        height=400, \n        full_screen = TRUE, \n        card_header(\"Monthly Malaria Indicators\"),    # informative card header\n        card_body(plotlyOutput(\"ts_plot\")),      # include plotlyOutput in the card body and name this output ts_plot\n        card_footer(\"Data source: DHIS2 export\") #informative card footer\n        ), \n      \n      card(\n        height = 200, \n        full_screen = TRUE,\n        card_header(\"Another Header\"), \n        card_body(\"Another Card\"), \n        card_footer(\"Another Footer\")\n        )\n      )\n    ),\n  \n  # &lt;&lt;&lt; NEW &gt;&gt;&gt; Defining the theme of your app \n  theme = bs_theme(\n    version = 5,                       # Use Bootstrap 5\n    bootswatch = \"darkly\",             # Choose a Bootswatch theme\n    base_font = font_google(\"Roboto\")  # Optional: use a modern font\n  )\n  \n)\n\n\n\nExercise 9\n\nTry replacing \"darkly\" with other Bootswatch themes like \"cosmo\", \"journal\", \"sandstone\", \"minty\", or \"cybord\" or select from the webpage linked.\n\nYou can also try out styles live inside your app using bs_themer(). To use it, just call bs_themer() once inside your server() function:\n\nserver &lt;- function(input, output) {\n  \n  bs_themer()\n  \n  # The rest of our code ... \n  \n} \n\n\nAs well as experimenting with pre-built themes you can also customise your own theming using the bs_themer for example if I played around in the theming and decided I wanted to use some colours similar to the AMMnet branding I could do this and then in my R console bs_themer lets us know what we changed and then we can add this to our theme = bs_theme() call. This is really helpful for playing with branding of your app to match with your organisations branding.\n\n theme = bs_theme(\n        version = 5, \n        fg = \"rgb(100, 16, 59)\",   # set the foreground colour\n        bg = \"rgb(253, 251, 252)\", # set the background colour \n        primary = \"#7C204F\",       # set the primary colour \n        secondary = \"#F7CBE6\"      # set the secondary colour\n    )\n\n\n\n\n\n\n\nCaution\n\n\n\nDon’t forget to remove bs_themer() from the server() once you’re done — it’s just for development.\n\n\nTo give users the opportunity to pick between a light or dark mode of your dashboard too you can simply implement the following in the ui\nHere we place it after the description in the sidebar but you can place it anywhere in the UI and set the default to start the app in light mode.\n\n# add dark/light switch \ninput_dark_mode(mode=\"light\")\n\n\n\nNow we have developed a theme we have another option for how to set the theme arguement for our value boxes. To ensure that when we change the theme of our app our value boxes automatically align with that theme we can set the theme arguement to be \"primary\" or “secondary\" and the boxes will inherit the colour values of the themes primary and secondary colours - let’s add this now.\n\n# Value Boxes in a single row that wraps responsive to screen size\n    layout_column_wrap( \n      value_box(\n        title = \"Total Cases Reported\",\n        value =  textOutput(\"total_cases_box\"), # reactive value taken from server side outputs\n        showcase = bsicons::bs_icon(\"journal-medical\"),\n        showcase_layout = \"top right\", \n        theme = \"secondary\" # app theme colour secondary\n      ), \n      \n      value_box(\n        title = \"Total Tests Reported\", \n        value = textOutput(\"total_tests_box\"), #render output call\n        showcase = bsicons::bs_icon(\"journal-medical\"), # update icon\n        showcase_layout = \"top right\", \n        theme = \"secondary\" #app theme colour secondary\n      )\n      \n      # addiditional boxes\n      # value_box(title = \"Value box 3\", value = 123), \n      # value_box(title = \"Value box 4\", value = 456), \n      # value_box(title = \"Value box 5\", value = 789), \n      # value_box(title = \"Value box 6\", value = 101112)\n      )\n\n\n\n\nExercise 10\n\nNow you have the value boxes set to inherit theme colours test out some more themes are render your app to see how these automatically change. Hint: try setting each value box theme to a different value."
  },
  {
    "objectID": "dashboard-workshop-materials.html#adding-a-logo-to-your-app",
    "href": "dashboard-workshop-materials.html#adding-a-logo-to-your-app",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Adding a Logo to Your App",
    "text": "Adding a Logo to Your App\nOnce you’ve customized the colors and fonts, finish off your look by adding a logo (or icon/banner) to the top of your sidebar = sidebar() code.\n\n#-sidebar---------\nsidebar = sidebar(\n  # add a logo \n  tags$img(src = \"AMMnet-logo.png\"), # make sure this image exists in a folder called www \n\nThen do the following:\nFolder Setup\n\nCreate a www/ folder in your app directory if it doesn’t exist.\nSave your logo or image as logo.png (or any name but it must match what you coded up).\nShiny will automatically read image files from that folder.\n\n\n\nExercise 11\n\nFind a logo online (e.g., your org, a flag, or malaria-related symbol or an image of your pet). Create and save it to your app’s www/ folder. Add it to the sidebar using tags$img()."
  },
  {
    "objectID": "dashboard-workshop-materials.html#wrapping-up-part-3-building-for-the-user",
    "href": "dashboard-workshop-materials.html#wrapping-up-part-3-building-for-the-user",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Wrapping up Part 3 — Building for the User",
    "text": "Wrapping up Part 3 — Building for the User\nIn Part 3, we made your app feel more professional and intuitive for end users:\n\nAdded validation messages to guide users when inputs are missing.\nIncluded descriptive text in your sidebar and main title.\nApplied a customizable visual theme with {bslib}.\nEnhanced branding by adding a logo.\nMade sure your value boxes inherit theme colors automatically.\n\nThese are small details — but they make your app feel polished, intentional, and ready to share with end users."
  },
  {
    "objectID": "dashboard-workshop-materials.html#computed-variables-and-conditional-widgets",
    "href": "dashboard-workshop-materials.html#computed-variables-and-conditional-widgets",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Computed Variables and Conditional Widgets",
    "text": "Computed Variables and Conditional Widgets\nOne of the powerful benefits of building dashboards in R is that we can compute new indicators directly inside our Shiny app using the data already loaded.\nLet’s take Test Positivity Rate (TPR) as an example. This isn’t directly stored in our dataset but can easily be computed:\n\nTPR = Confirmed Cases / Malaria Tests\n\nWe will create this as a computed reactive output, and allow the user to toggle whether they want to view this indicator.\nThis approach is helpful in malaria dashboards where:\n\nSome indicators are derived\nUsers may want optional, on-demand metrics\nYou want to avoid recalculating unnecessary metrics until they are requested\n\nLet’s start by giving the user a checkbox to control whether to calculate and display TPR:\nBelow our current data series selection include a new Input:\n\n    #-sidebar---------\n    sidebar = sidebar(\n      \n      # add a logo \n      tags$img(src = \"AMMnet-logo.png\"), # make sure this image exists in a folder called www \n      \n      # informative title\n      p(\"Dashboard for examining province level malaria indicators in Laos.\n         Select a province and data series to view the trends over time.\"),\n      \n      # add dark/light switch \n      input_dark_mode(mode=\"light\"),\n      \n      # Province selection \n      selectInput(\n        inputId = \"province_select\",  # ID value\n        label = \"Select a Province:\", # UI side Title\n        choices = c(\"\", sort(unique(app_data$organisation_unit))), # empty first value followed by all of our unique org_unit names\n        selected = \"\" # default value that the application starts with as selected - in our case we want this to be blank. \n        ), \n      \n      # Data series toggle \n      checkboxGroupInput(\n        inputId = \"series_select\", # give usable ID\n        label = \"Select data series:\", # UI side title\n        choices = c(\"Confirmed Cases\" = \"malaria_cases\", # filter variables with nice formatting for the UI\n                    \"Malaria Tests\"  = \"malaria_tests\"),\n        selected = NULL #ensure selection is empty initially\n      ), \n      \n      # Test Positivity toggle \n      checkboxInput(\n        inputId = \"include_tpr\", # name ID\n        label = \"Calculate and diaplay Test Positivity Rate (TPR)\", # User side title\n        value = FALSE # set to be unclicked as default\n      )\n      )\n\nHowever — we only want this checkbox to be available when both malaria_cases and malaria_tests are selected for plotting. Otherwise, calculating TPR doesn’t make sense.\nShiny allows us to dynamically render UI elements using renderUI(). We’ll modify our sidebar to only display the TPR toggle when both series are selected. Replace the code in the ui with:\n\n# &lt;&lt;&lt; Replace static checkbox with this dynamic output using the uiOutput() call\nuiOutput(\"tpr_checkbox_ui\")\n\nThen add this logic to your server() function:\n\n#-Conditional UI element for TPR checkbox------------------------------------------------------\n  output$tpr_checkbox_ui &lt;- renderUI({\n    \n    if (all(c(\"malaria_cases\", \"malaria_tests\") %in% input$series_select)) {\n      # Only show the checkbox if both series are selected\n      checkboxInput(\n        inputId = \"include_tpr\", # name ID\n        label = \"Calculate and diaplay Test Positivity Rate (TPR)\", # User side title\n        value = FALSE # set to be unclicked as default\n      )\n    } else {\n      # If not both series selected, return NULL to not display the checkbox\n      NULL\n    }\n  })\n\n\n\n\n\n\n\n\nOnce the toggle exists, we can build a reactive plot that only displays if:\n\nA province is selected\nBoth indicators are selected\nThe TPR checkbox is enabled\n\nInside the UI element update the empty card with the following logic:\n\n   # Cards in a single row\n    layout_columns(\n      card(\n        height=400, \n        full_screen = TRUE, \n        card_header(\"Monthly Malaria Indicators\"),# informative card header\n        card_body(plotlyOutput(\"ts_plot\")),       # include plotlyOutput in the card body and name this output ts_plot\n        card_footer(\"Data source: DHIS2 export\")  #informative card footer\n        ), \n      \n      card(\n        height = 400,\n        full_screen = TRUE,  \n        card_header(\"Monthly Malaria Test Positivity\"), # informative card header\n        card_body(plotlyOutput(\"tpr_plot\")), # include plotlyOutput in the card body and name this output tpr_plot\n        card_footer(\"Data source: DHIS2 export\") # informative card footer\n        )\n      )\n      )\n\nInside your server() function we can add new plot code along with some addiditional prompts to the user:\n\n#-Conditional rendering of TPR plot------------------------------------------------------------\n  output$tpr_plot &lt;- renderPlotly({\n    \n    # Use validate + need to provide informative user messages\n    validate(\n      need(input$include_tpr, \"Enable TPR toggle to display plot.\"),\n      need(input$province_select != \"\", \"Please select a province to view data.\"),\n      need(length(input$series_select) == 2, \"Please select both malaria cases and malaria tests to calculate TPR.\")\n    )\n    \n    # calculate TPR - Test Positivity Rate\n    df &lt;- \n      province_data() %&gt;% # get the filtered province data\n      pivot_wider(names_from = var_name, values_from = value) %&gt;% # pivot the data wider to have cases and tests in separate columns\n      arrange(period) %&gt;% # arrange by period\n      mutate(\n        tpr = round((malaria_cases / malaria_tests) * 100, 2) # calculate TPR as a percentage - rounded to 2 decimal places\n      )\n    \n    # Plot the TPR over time\n    p &lt;- \n      ggplot(df, aes(x = period, y = tpr)) + \n      geom_point(color = \"#FECC01\") +\n      labs(\n        title = paste(\"Test Positivity Rate (TPR) in:\", input$province_select), # add selected province to the title\n        x = \"Month\",\n        y = \"TPR (%)\"\n      ) +\n      theme_minimal() +\n      scale_y_continuous(limits = c(0, 100)) # set y-axis limits from 0 to 100%\n    \n    ggplotly(p) # convert ggplot to plotly object\n    \n  })\n\n\nOnce a user safely selects all of the inputs a plot will generate.\n\nvalidate() + need() provide friendly user-facing error messages inside the plot container.\nOnly once all conditions are met, the plot is rendered.\nThis is much more user-friendly than simply leaving the plot blank or throwing errors!\n\n\n\nExrecise 12\nNow let’s reinforce your learning with a short coding challenge:\n\nCreate a new value box that displays the average TPR for the year, but only when the checkbox include_tpr is turned on.\n\nYour logic should:\n\nCalculate the TPR inside the server (same as you did for the other value boxes) but use sumarise(tpr = mean(tpr, na.rm = TRUE) to take the average value.\nConditionally display the value box only when the checkbox include_tpr is TRUE\nKeep using province_data() for your data filtering\nYou can use renderUI() to conditionally create the value box.\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\nCompute average TPR: Add this to your server():\n\n  #-average TPR value box-----------------------------------------------------------------\n  output$tpr_value &lt;- renderText({\n    \n    req(input$include_tpr) # requires the TPR check to be TRUE \n    \n    # data processing\n    df &lt;- \n      province_data() %&gt;% # filters to province\n      pivot_wider(names_from = var_name, values_from = value) %&gt;% #widens data frame to have a column per indicator \n      mutate(\n        tpr = round((malaria_cases / malaria_tests) * 100, 2) # calculates TPR as a percentage\n      ) %&gt;%\n      summarise(\n        tpr = mean(tpr, na.rm=TRUE) # takes average of TPR on % scale \n        ) \n    \n    avg_tpr &lt;- round(df$tpr, 1) # rounds to one decimal place\n    \n    avg_tpr # returns value \n  })\n\nUpdate UI code to include\n\nlayout_column_wrap( \n      value_box(\n        title = \"Total Cases Reported\",\n        value =  textOutput(\"total_cases_box\"), # reactive value taken from server side outputs\n        showcase = bsicons::bs_icon(\"journal-medical\"),\n        showcase_layout = \"top right\", \n        theme = \"secondary\" # app theme colour secondary\n      ), \n      \n      value_box(\n        title = \"Total Tests Reported\", \n        value = textOutput(\"total_tests_box\"), #render output call\n        showcase = bsicons::bs_icon(\"journal-medical\"), # update icon\n        showcase_layout = \"top right\", \n        theme = \"secondary\" #app theme colour secondary\n      ), \n      #conditional value box for TPR\n      uiOutput(\"tpr_value_box\") # this is a reactive value box that will only show if the TPR checkbox is selected\n      )\n\nTell the server what to place in “tpr_value”\n\n#-Render the value box for TPR if checkbox is selected---------------------------------------------\noutput$tpr_value_box &lt;- renderUI({\n  # Check if the TPR checkbox is selected\n  if (isTRUE(input$include_tpr))  { # requires TPR check to be active\n    \n    # standard value box set up \n    value_box(\n      title = \"Average TPR (%)\",       # Title\n      value = textOutput(\"tpr_value\"), # using condiditional value \n      showcase = bsicons::bs_icon(\"percent\"), #Icon\n      showcase_layout = \"top right\",   # placement\n      theme = \"secondary\"              # colour theme\n    )\n  } else {\n    NULL # if not checked then nothing is displayed\n  }\n})\n\n\n\n\n\nYou may notice here that our app has a blank space where the Test Positivity values are expected to be which doesn’t look very professional.\nTo prevent the empty placeholder space when the toggle is off, we can dynamically generate the entire set of value boxes using renderUI().\nInstead of placing uiOutput(\"tpr_value_box\") inside your existing layout_column_wrap(), we will let the server fully control which value boxes appear at any moment.\nFirst we replace the current ui code for our value boxes with the following:\n\n# Value Boxes in a single row that wraps responsive to screen size and data selection\nuiOutput(\"value_boxes\")\n\nThen link the value_boxes to a server side output:\n\n#-Value Box dynamic number based on TPR toggle-----------------------------------------------------\noutput$value_boxes &lt;- renderUI({\n  \n  # Always include these two\n  boxes &lt;- list(\n    value_box(\n      title = \"Total Cases Reported\",\n      value = textOutput(\"total_cases_box\"),\n      showcase = bsicons::bs_icon(\"journal-medical\"),\n      showcase_layout = \"top right\", \n      theme = \"secondary\"\n    ),\n    value_box(\n      title = \"Total Tests Reported\", \n      value = textOutput(\"total_tests_box\"),\n      showcase = bsicons::bs_icon(\"journal-medical\"), \n      showcase_layout = \"top right\", \n      theme = \"secondary\" \n    )\n  )\n  \n  # Conditionally add TPR box only if checkbox is ON\n  if (isTRUE(input$include_tpr)) {\n    boxes &lt;- append(boxes, list(\n      value_box(\n        title = \"Average TPR (%)\",\n        value = textOutput(\"tpr_value\"),\n        showcase = bsicons::bs_icon(\"percent\"),\n        showcase_layout = \"top right\",\n        theme = \"secondary\"\n      )\n    ))\n  }\n  \n  # Wrap all boxes inside layout_column_wrap\n  layout_column_wrap(!!!boxes)\n})\n\n\nThe !!! operator (from rlang) safely unpacks the list into multiple arguments for layout_column_wrap(). This allows us to dynamically build the list of value boxes.\n\n\n\nNow your app will only show the TPR value box when appropriate — without leaving any empty space when the toggle is off!\n\nrenderUI() gives you full control over when and how UI elements appear.\nYou avoid “empty shells” by only adding UI objects when their underlying data exists.\nThe user experience is cleaner, avoids confusion, and reflects the actual available information."
  },
  {
    "objectID": "dashboard-workshop-materials.html#input-selection-within-cards",
    "href": "dashboard-workshop-materials.html#input-selection-within-cards",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Input Selection Within Cards",
    "text": "Input Selection Within Cards\nHaving the data series selection buttons in the sidebar when they control all of the plots on the dashbaord is okay but if we want to add addiditional plots a long list of selection boxes may be confusing for the user.\nWhat we can do is build a card with a sidebar for selections directly within that card.\nFor the current plots of reported cases and tests and calculated TPR, lets create a single card with a sidebar within that card that directs the user for what data to select to display plots.\nReplace our current two card() layout with the following:\n\n# Card with a sidebar for input selection \n    card(\n      height = 500, \n      full_screen = TRUE, \n      # global card header\n      card_header(\"Monthyl Malaria Indicator Trends\"),\n      # sidebar layout with sidebar and card body\n      layout_sidebar(\n        \n        # add the sidebar with input elements\n        sidebar = list(\n          # include original data series checkboes\n          checkboxGroupInput(\n            inputId  = \"series_select\",\n            label    = \"Select data series:\",\n            choices  = c(\n              \"Confirmed Cases\" = \"malaria_cases\",\n              \"Malaria Tests\"   = \"malaria_tests\"\n            )\n          ),\n          # condiditionally render TPR checkbox\n          uiOutput(\"tpr_checkbox_ui\")\n        ),\n        \n        # include the card body with the plots\n        card_body(\n          # wrap the calls into a column layout\n          layout_column_wrap(\n            plotlyOutput(\"ts_plot\"),\n            plotlyOutput(\"tpr_plot\")\n          )\n        ),\n        card_footer(\"Data source: DHIS2 export\") # informative card footer\n      )\n    )\n\nAnd REMOVE the data series selection and TPR selection from the sidebar code - keep it only in our new card.\n\nThis functionality would be nicer if first plot could take up the full width of the card when the TPR box is not checked - we can acheive this by making the following changes:\nInstead of hard-coding the layout inside card_body() we can replace it with a dynamic UI placeholder:\n\n   # Card with a sidebar for input selection \n    card(\n      full_screen = TRUE, \n      # global card header\n      card_header(\"Monthyl Malaria Indicator Trends\"),\n      # sidebar layout with sidebar and card body\n      layout_sidebar(\n        \n        # add the sidebar with input elements\n        sidebar = list(\n          # include original data series checkboes\n          checkboxGroupInput(\n            inputId  = \"series_select\",\n            label    = \"Select data series:\",\n            choices  = c(\n              \"Confirmed Cases\" = \"malaria_cases\",\n              \"Malaria Tests\"   = \"malaria_tests\"\n            )\n          ),\n          # condiditionally render TPR checkbox\n          uiOutput(\"tpr_checkbox_ui\")\n        ),\n        \n        # include the card body with the plots\n        card_body(\n          # UI output that will dynamically render different layout\n          uiOutput(\"ts_plots_ui\")\n        ),\n        card_footer(\"Data source: DHIS2 export\") # informative card footer\n      )\n    )\n\nAnd then we can update the server code to conditionally layout the plots based on whether the TPR checkbox is selected or not:\n\n#-conditional layout for time series plots---------------------------------------------\noutput$ts_plots_ui &lt;- renderUI({\n  \n  # If TPR is selected, show both plots side by side\n  if (isTRUE(input$include_tpr)) { \n    # Show both plots side by side\n    layout_columns(\n      col_widths = c(6, 6),  # 50-50 width\n      plotlyOutput(\"ts_plot\"),\n      plotlyOutput(\"tpr_plot\")\n    )\n    \n  # If TPR is not selected, show only the main time series plot\n  } else {\n    # Show single plot full width\n    layout_columns(\n      col_widths = c(12),  # full width\n      plotlyOutput(\"ts_plot\")\n    )\n  }\n  \n})\n\n\n\nStretch Exercise\n🎯 Your Task - add a new card panel below the current plots showing a time series plot of incidence per 1,000 people in the selected province.\nThis plot will:\n\nUse data where var_name == \"malaria_cases_per_1000\"\nShow a single line plot with one point per month\nAppear in a new card() component with a header and footer\nOnly display when a province input$province_select is selected, prior to showing a plot display a helpful message to let users know to select a province\nUse renderPlotly() to make it interactive\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\nAdd a new card to the UI\n\n# incidence plot card \n    card(\n      height = 400,\n      full_screen = TRUE,\n      card_header(\"Monthyl Malaria Incidence Trends\"), # card header\n      card_body(plotlyOutput(\"inc_plot\")),     # plotly output for the incidence plot\n      card_footer(\"Data source: DHIS2 export\") # informative card footer\n    )\n\nAdd plot code to the server\n\noutput$inc_plot &lt;- renderPlotly({\n  \n  # Add messages to inform user to select a province\n  validate(\n    need(input$province_select != \"\", \"Please select a province to view data.\")\n  )\n  \n  # filter dataset\n  df &lt;- \n    province_data() %&gt;% # filtr ptovince data\n    filter(var_name == \"malaria_cases_per_1000\") # select inc var\n  \n  # Ensure there is data to plot\n  validate(\n    need(nrow(df) &gt; 0, \"No incidence data available for this province.\")\n  )\n  \n  # Plot the incidence over time \n  p &lt;- \n    ggplot(df, aes(x = period, y = value)) +\n    geom_line(color = \"#FECC01\") +\n    geom_point(color = \"#FECC01\") +\n    labs(\n      title = paste(\"Malaria Incidence in:\", input$province_select),\n      x = \"Month\",\n      y = \"Incidence (per 1,000)\"\n    ) +\n    theme_minimal()\n  \n  ggplotly(p)\n})"
  },
  {
    "objectID": "dashboard-workshop-materials.html#including-leaflet-maps",
    "href": "dashboard-workshop-materials.html#including-leaflet-maps",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Including Leaflet Maps",
    "text": "Including Leaflet Maps\nNow that your dashboard includes time series and summary statistics, let’s add a spatial view using an interactive map. This will help users visually explore malaria burden across provinces.\nWe’ll use the {leaflet} package to create a map of average annual incidence per 1,000 people, and we’ll highlight the selected province from the sidebar dropdown.\nThink of leaflet as allowing us to use a google maps style map to our dashboard rather than a static image.\nWe will build an interactive leaflet map that:\n\nFills each province with a color based on average annual incidence\nAdds a legend for the color scale\nHighlights the selected province with a bold outline\nShows tooltips when hovering over provinces\n\nFor plotting maps we need to ensure we have a shapefile at the correct administrative boundary - download the file and add it to your data-outputs folder.\nDownload data-outputs.zip\nAt the top of your app (after loading your libraries and data), add:\n\nadm1_shp &lt;- st_read(\"./data-outputs/adm1_shapefile.shp\")\n\nAdd a new column layout to ensure the map and the incidence plot fall on the same row of the dashboard and adjust the widths to allow more space for the line plot.\n\n# incidence plot card - including map \n    layout_columns(\n      # width - adjust the width to give some more space to the line chart\n      col_widths = c(7,5), \n      card(\n        height = 400,\n        full_screen = TRUE,\n        card_header(\"Monthly Malaria Incidence Trends\"),\n        card_body(plotlyOutput(\"inc_plot\", height = \"350px\")),\n        card_footer(\"Data source: DHIS2 export\")\n      ), \n      card(\n        height = 400,\n        full_screen = TRUE, \n        card_header(\"Average Annual Incidence Map\"),\n        card_body(leafletOutput(\"inc_map\", height = \"350px\")),\n        card_footer(\"Data source: HumData for shape files, DHIS2 for malaria data\")\n      )\n    )\n\nNow buid the Maps using Leaflet Syntax in the server. We add a highlight outline to the Province that the user has selected.\n\n# Incidence leaflet map----------------------------------------------------------------------\noutput$inc_map &lt;- renderLeaflet({\n  \n  # Add messages to inform user to select a province\n  validate(\n    need(input$province_select != \"\", \"Please select a province to view data.\")\n  )\n  \n  # Summarise incidence by province - no need to use filtered data as \n  # we want all provinces shown on the map\n  df &lt;- \n    app_data %&gt;%\n    filter(var_name == \"malaria_cases_per_1000\") %&gt;% # filter to incidence data\n    group_by(organisation_unit) %&gt;%  # group by organisation unit\n    summarise(inc = mean(value, na.rm = TRUE)) # calculate mean incidence per 1,000\n  \n  # Join data to spatial file\n  df_shape &lt;- left_join(adm1_shp, df, by = c(\"org_unit\" = \"organisation_unit\"))\n  \n  # Create color palette \n  pal &lt;- colorNumeric(\n    palette = \"YlOrRd\",\n    domain = df_shape$inc, # use the incidence values for color mapping\n    na.color = \"#f0f0f0\"\n  )\n  \n  # Create the leaflet map \n  leaflet(df_shape) %&gt;% # use the spatial data\n    addProviderTiles(providers$CartoDB.Positron) %&gt;% # adds base map layer\n    addPolygons( \n      # add polygons for each province\n      fillColor = ~pal(inc), # fill color based on incidence\n      weight = ~ifelse(org_unit == input$province_select, 3, 1), # highlight selected province with thicker border\n      color = ~ifelse(org_unit == input$province_select, \"#7C204F\", \"black\"), # set border color\n      opacity = 1, # set opacity of the border\n      fillOpacity = 0.8, # set fill opacity \n      label = ~paste0(org_unit, \": \", round(inc, 1), \" per 1,000\"), # add labels with province name and incidence\n      highlightOptions = highlightOptions(\n        # highlight options for interactivity\n        weight = 3, # thicker border on hover\n        color = \"#333\", # darker border on hover\n        fillOpacity = 0.9, # fill opacity on hover\n        bringToFront = TRUE # bring polygon to front on hover\n      )\n    ) |&gt;\n    # Add the color legend\n    addLegend(\n      pal = pal,\n      values = df_shape$inc,\n      title = \"Avg Incidence (per 1,000)\",\n      position = \"bottomright\"\n    )\n})\n\n\nIn the current app, your leaflet() map uses: addProviderTiles(providers$CartoDB.Positron)\nThis adds a light, minimal background map. But what if you wanted to give users a different map style?\n\nExercise 13\n\nExplore other available background tiles using the leaflet::providers object. You can see a full list by running this command in your R console: leaflet::providers Replace CartoDB.Positron with or another of your choice. Hint: You only need to replace the argument to addProviderTiles(). For example: addProviderTiles(providers$Esri.WorldImagery)\n\nSet the column widths to a new value so that the first incidnece plot takes up more of the row space than the map."
  },
  {
    "objectID": "dashboard-workshop-materials.html#adding-a-table-output",
    "href": "dashboard-workshop-materials.html#adding-a-table-output",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Adding a Table Output",
    "text": "Adding a Table Output\nIn many dashboards, tables complement visualizations by providing users with detailed numeric outputs.\nShiny has great support for interactive tables using the DT package.\nLet’s create a summary table that:\n\nAggregates total cases, total tests, average TPR and average incidence by province and includes the number of months that data is reported for in the province\nHighlights the currently selected province\nDisplays all provinces at once\nIs interactive (sortable, searchable, paginated)\n\nWe will use renderDT() inside the server and DTOutput() inside the UI to create this table.\n\n# DT output \n    card(\n      card_header(\"Summary Table\"), # card header\n      card_body(DTOutput(\"summary_data\")), # DT output \n      card_footer(\"Aggregated Annual Values per Province\") # card footer\n    )\n\nNow add this code inside your server:\n\n# -Summary table of annual values-------------------------------------------------------------\noutput$summary_data &lt;- renderDT({\n  \n  # Add messages to inform user to select a province\n  validate(\n    need(input$province_select != \"\", \"Please select a province to view data.\")\n  )\n  \n  # Filter and summarise the app_data to create a summary table using all provinces \n  df &lt;- \n    app_data %&gt;%\n    # Filter to relevant variables\n    filter(var_name %in% c(\"malaria_cases\", \"malaria_tests\", \"malaria_cases_per_1000\")) %&gt;%\n    # Pivot the data to wide format\n    pivot_wider(\n      names_from = var_name,\n      values_from = value,\n    ) %&gt;% \n    # Group by organisation unit (province)\n    group_by(organisation_unit) %&gt;% \n    # Calculate TPR and summarise the data\n    mutate(tpr = round((malaria_cases / malaria_tests) * 100, 1)) %&gt;% \n    # Summarise the data to get total cases, total tests, average TPR, and average incidence\n    # And two new variables - reporting months for cases and tests\n    summarise(\n      total_cases = sum(malaria_cases, na.rm = TRUE),\n      total_tests = sum(malaria_tests, na.rm=TRUE), \n      avg_tpr = round(mean(tpr, na.rm=TRUE), 1),\n      avg_inc = round(mean(malaria_cases_per_1000, na.rm=TRUE),1), \n      reporting_months_cases = sum(!is.na(malaria_cases)),\n      reporting_months_tests = sum(!is.na(malaria_tests))\n    ) %&gt;% \n    # Rename columns for nice table headings\n    rename(\n      Province = organisation_unit,\n      `Total Cases` = total_cases,\n      `Total Tests` = total_tests,\n      `Average TPR (%)` = avg_tpr,\n      `Avg Incidence` = avg_inc,\n      `Case Reporting Months` = reporting_months_cases,\n      `Test Reporting Months` = reporting_months_tests\n    )\n  \n  # Build DT object\n  dt &lt;- datatable(\n    df, # Create a datatable from the summarised data\n    rownames = FALSE,  # disable row names\n    options = list(\n      pageLength = 10, # number of rows per page\n      dom = \"tip\",     # table controls\n      autoWidth = TRUE # auto width for columns\n    )\n  )\n  \n  # Highlight selected province\n  if (input$province_select != \"\") {\n    # Apply row styling to highlight the selected province\n    selected &lt;- input$province_select \n    # Use formatStyle to apply bold font weight to the selected province row\n    dt &lt;- dt %&gt;%\n      formatStyle(\n        \"Province\",\n        target = \"row\",\n        fontWeight = styleEqual(selected, \"bold\")\n      )\n  }\n  \n  # Return the datatable object\n  dt\n})\n\nWhen you run your app, you now have a sortable, searchable summary table with all provinces. The currently selected province row is bolded too.\n\n\nExercise 14 - Tricky\n\nUsers may want to export the summary data to analyze offline, share with colleagues, or integrate into reports. Your Task: Add a Download CSV button that allows users to download the table displayed above.\n\nHints:\n\nIn your UI, use downloadButton() to add a button to the card.\nIn your server, create a downloadHandler() to generate the CSV file.\nYou can put the button inside the same card as your table, e.g., just above DTOutput().\nFor downloading logic first check out the downloadHandler function logic through typing ?downloadHandler in the Console and check with the example below.\n\n\n\n\n\n\n\nShow Solution\n\n\n\n\n\nAdd the following to your UI\n\n# DT output \n    card(\n      card_header(\"Summary Table\"), # card header\n      card_body(\n        downloadButton(\"download_summary\", \"Download CSV\"), # download button\n        DTOutput(\"summary_data\") # DT output\n        ),  \n      card_footer(\"Aggregated Annual Values per Province\") # card footer\n    )\n\nAnd the following to the server:\n\n#-Code for handling data downloads--------------------------------------------------------------\n\n# Create a reactive data frame for the summary table to pull data from same logic as in the\n# data rendering code\nsummary_table_data &lt;- reactive({\n  app_data |&gt;\n    filter(var_name %in% c(\"malaria_cases\", \"malaria_tests\", \"malaria_cases_per_1000\")) |&gt;\n    pivot_wider(names_from = var_name, values_from = value) |&gt; \n    group_by(organisation_unit) |&gt; \n    mutate(tpr = round((malaria_cases / malaria_tests) * 100, 2)) |&gt; \n    summarise(\n      total_cases = sum(malaria_cases, na.rm = TRUE),\n      total_tests = sum(malaria_tests, na.rm=TRUE), \n      avg_tpr = round(mean(tpr, na.rm=TRUE), 1),\n      avg_inc = round(mean(malaria_cases_per_1000, na.rm=TRUE),1), \n      reporting_months_cases = sum(!is.na(malaria_cases)),\n      reporting_months_tests = sum(!is.na(malaria_tests))\n    ) |&gt; \n    rename(\n      Province = organisation_unit,\n      `Total Cases` = total_cases,\n      `Total Tests` = total_tests,\n      `Average TPR (%)` = avg_tpr,\n      `Avg Incidence` = avg_inc,\n      `Case Reporting Months` = reporting_months_cases,\n      `Test Reporting Months` = reporting_months_tests\n    )\n})\n\n\n# Enable file download \noutput$download_summary &lt;- downloadHandler(\n  # Define the filename for the downloaded file\n  filename = function() { paste0(\"summary_data_\", Sys.Date(), \".csv\") }, # This will create a file name with the current date\n  \n  # Define the content of the file \n  content = function(file) {\n    write.csv(summary_table_data(), file, row.names = FALSE) # Write the summary table data to a CSV file\n  }\n)"
  },
  {
    "objectID": "dashboard-workshop-materials.html#expanding-functionality",
    "href": "dashboard-workshop-materials.html#expanding-functionality",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Expanding Functionality",
    "text": "Expanding Functionality\n\nAdd additional filters such as date ranges or multiple administrative levels\nInclude new calculated indicators directly within the dashboard\nBuild more complex plots, for example:\n\nAdding trendlines or smoothing\nFaceting across multiple provinces\nAllowing users to interactively select multiple indicators for comparison\n\nAllow users to upload their own datasets into the dashboard directly\nBuild drill-down functionality to explore district- or facility-level data"
  },
  {
    "objectID": "dashboard-workshop-materials.html#organizing-and-scaling-your-code",
    "href": "dashboard-workshop-materials.html#organizing-and-scaling-your-code",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Organizing and Scaling Your Code",
    "text": "Organizing and Scaling Your Code\nAs dashboards become more complex, managing code in a single app file can become difficult. You may want to:\n\nSplit your code into multiple files, separating UI, server, and helper functions\nUse modular design with callModule() or moduleServer() to create reusable components\nBuild centralized helper functions (e.g., helpers.R) for repeated tasks such as data filtering or value box creation\n\nThis makes your code easier to maintain and scale over time."
  },
  {
    "objectID": "dashboard-workshop-materials.html#deployment-and-sharing",
    "href": "dashboard-workshop-materials.html#deployment-and-sharing",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Deployment and Sharing",
    "text": "Deployment and Sharing\nThere are multiple options for sharing Shiny dashboards:\n\nRunning locally for personal or internal use\nPublishing to cloud services such as shinyapps.io (free options)\nDeploying on enterprise platforms such as Posit Connect ($$)\nHosting internally on government or institutional servers\n\nWhen deploying dashboards, consider whether your data includes any sensitive or confidential information. Secure hosting, access controls, and user authentication may be required depending on your intended audience."
  },
  {
    "objectID": "dashboard-workshop-materials.html#styling-and-user-experience",
    "href": "dashboard-workshop-materials.html#styling-and-user-experience",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Styling and User Experience",
    "text": "Styling and User Experience\nIn addition to the core functionality, improving the design and appearance of your dashboard can make it easier to use:\n\nCustomize your bslib themes to align with institutional branding\nProvide users with contextual help such as pop-up modals or collapsible panels to explain indicators or methods\nUse dynamic tooltips, colour schemes, or alert messages to highlight important information"
  },
  {
    "objectID": "dashboard-workshop-materials.html#useful-resources-for-further-learning",
    "href": "dashboard-workshop-materials.html#useful-resources-for-further-learning",
    "title": "Hands-On Shiny: Routine Malaria Data Dashboard Workshop",
    "section": "Useful Resources for Further Learning",
    "text": "Useful Resources for Further Learning\n\nShiny Official Documentation\nMastering Shiny by Hadley Wickham (free online book)\nbslib Documentation for theming\nShiny GalleryExamples for code samples"
  }
]